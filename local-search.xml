<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>隐私政策</title>
    <link href="/2020/12/15/%E6%97%A5%E7%A8%8B%E6%97%A5%E5%8E%86%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/"/>
    <url>/2020/12/15/%E6%97%A5%E7%A8%8B%E6%97%A5%E5%8E%86%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/</url>
    
    <content type="html"><![CDATA[<p>隐私政策</p><p>本应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本应用会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。本应用会不时更新本隐私权政策。 您在同意本应用服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本应用服务使用协议不可分割的一部分。</p><ol><li>适用范围</li></ol><p>(a) 在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器和计算机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；</p><p>您了解并同意，以下信息不适用本隐私权政策：</p><p>(a) 本应用收集到的您在本应用发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情；</p><p>(b) 违反法律规定或违反本应用规则行为及本应用已对您采取的措施。</p><ol start="2"><li>信息使用</li></ol><p>(a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。</p><p>(b) 本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。</p><ol start="3"><li>信息披露</li></ol><p>在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息：</p><p>(a) 经您事先同意，向第三方披露；</p><p>(b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息；</p><p>(c) 根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；</p><p>(d) 如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向第三方披露；</p><p>(e) 如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷；</p><p>(f) 在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。</p><p>(g) 其它本应用根据法律、法规或者网站政策认为合适的披露。</p><ol start="4"><li>信息存储和交换</li></ol><p>本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。</p><ol start="5"><li>Cookie的使用</li></ol><p>(a) 在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。</p><p>(b) 您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。</p><p>(c) 通过本应用所设cookies所取得的有关信息，将适用本政策。</p><ol start="6"><li>信息安全</li></ol><p>(a) 本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。</p><p>(b) 在使用本应用网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对</p><p>7.本隐私政策的更改</p><p>(a)如果决定更改隐私政策，我们会在本政策中、本公司网站中以及我们认为适当的位置发布这些更改，以便您了解我们如何收集、使用您的个人信息，哪些人可以访问这些信息，以及在什么情况下我们会透露这些信息。</p><p>(b)该应该作者保留随时修改本政策的权利，因此请经常查看。如对本政策作出重大更改，本公司会通过网站通知的形式告知。</p><p>请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，尤其是本应用用户名及密码发生泄露，请您立即联络本应用客服，以便本应用采取相应措施。 </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mac 终端查看当前使用的什么脚本，以及切换</title>
    <link href="/2019/10/20/mac-%E7%BB%88%E7%AB%AF%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E8%84%9A%E6%9C%AC%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%88%87%E6%8D%A2/"/>
    <url>/2019/10/20/mac-%E7%BB%88%E7%AB%AF%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E8%84%9A%E6%9C%AC%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>查看<br>echo $SHELL</p><p>切换 bash<br>要在macOS上更改用户帐户的默认外壳，只需chsh -s在“终端”窗口中运行（更改外壳）命令。<br>通过运行以下命令将默认Shell更改为Bash：chsh -s / bin / bash</p><p>切换 zsh<br>通过运行以下命令，将默认shell更改回Zsh：<br>chsh -s / bin / zsh<br>出现提示时输入密码。关闭终端窗口并重新打开它之后，您将使用Zsh。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>macbook 电池健康程度检测终端命令</title>
    <link href="/2019/10/20/macbook-%E7%94%B5%E6%B1%A0%E5%81%A5%E5%BA%B7%E7%A8%8B%E5%BA%A6%E6%A3%80%E6%B5%8B%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/"/>
    <url>/2019/10/20/macbook-%E7%94%B5%E6%B1%A0%E5%81%A5%E5%BA%B7%E7%A8%8B%E5%BA%A6%E6%A3%80%E6%B5%8B%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>ioreg -rn AppleSmartBattery | grep -i capacity</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Gitlab+fastlane 持续集成（小白从0到1）</title>
    <link href="/2019/10/20/Gitlab-fastlane-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%EF%BC%88%E5%B0%8F%E7%99%BD%E4%BB%8E0%E5%88%B01%EF%BC%89/"/>
    <url>/2019/10/20/Gitlab-fastlane-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%EF%BC%88%E5%B0%8F%E7%99%BD%E4%BB%8E0%E5%88%B01%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h5 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h5><ol><li>在gitlab新建项目</li><li>配置并启动gitlab-runner</li><li>安装并配置fastlane</li><li>配置.gitlab-ci.yml文件</li></ol><h5 id="1、在gitlab新建项目"><a href="#1、在gitlab新建项目" class="headerlink" title="1、在gitlab新建项目"></a>1、在gitlab新建项目</h5><p>做开发的都会</p><h5 id="2、配置gitlab-runner"><a href="#2、配置gitlab-runner" class="headerlink" title="2、配置gitlab-runner"></a>2、配置gitlab-runner</h5><p><a href="https://docs.gitlab.com/runner/register/index.html">gitlab-runner文档</a></p><p><a href="https://www.jianshu.com/p/c7995ad64f48">gitlab-runner的配置——for Mac</a></p><h5 id="3、安装并配置fastlane"><a href="#3、安装并配置fastlane" class="headerlink" title="3、安装并配置fastlane"></a>3、安装并配置fastlane</h5><h6 id="安装fastlane"><a href="#安装fastlane" class="headerlink" title="安装fastlane"></a>安装fastlane</h6><p><a href="https://s0docs0fastlane0tools.icopy.site/">fastlane中文文档</a></p><p>注意：任何的安装可能都需要你配置下环境变量</p><h6 id="安装firim插件"><a href="#安装firim插件" class="headerlink" title="安装firim插件"></a>安装firim插件</h6><pre><code class="hljs ebnf"><span class="hljs-attribute">fastlane add_plugin firim</span></code></pre><p>注意：这个要在工程fastlane文件夹所在目录执行</p><h6 id="Appfile"><a href="#Appfile" class="headerlink" title="Appfile"></a>Appfile</h6><p>用于存放 app_identifier（bundle id）、 apple_id(appl开发中账号邮箱地址)、team_id、itc_team_id</p><h6 id="Deliverfile"><a href="#Deliverfile" class="headerlink" title="Deliverfile"></a>Deliverfile</h6><p>deliver工具的配置文件</p><h6 id="Fastfile"><a href="#Fastfile" class="headerlink" title="Fastfile"></a>Fastfile</h6><p>用于管理你所创建的 lane，lane 则会调用 action。</p><h6 id="Gymfile"><a href="#Gymfile" class="headerlink" title="Gymfile"></a>Gymfile</h6><p><a href="http://docs.fastlane.tools/actions/gym/">官方文档</a></p><p><a href="https://www.jianshu.com/p/f62c8a980c35">Fastlane - gym</a></p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p3931" alt="18aa7066fa1a32b15eca900e3670743f.png"></p><h6 id="Snapfile"><a href="#Snapfile" class="headerlink" title="Snapfile"></a>Snapfile</h6><p>用于指定需要进行屏幕截图的设备类型和语种。</p><h6 id="Matchfile"><a href="#Matchfile" class="headerlink" title="Matchfile"></a>Matchfile</h6><p><a href="https://www.jianshu.com/p/5962940522a2">使用Match来管理代码签名</a></p><h6 id="Pluginfile"><a href="#Pluginfile" class="headerlink" title="Pluginfile"></a>Pluginfile</h6><p>安装的插件会在这里面显示，如前面提到的插件firim安装之后,Pluginfile中：</p><pre><code class="hljs nginx"><span class="hljs-attribute">gem</span> <span class="hljs-string">&#x27;fastlane-plugin-firim&#x27;</span></code></pre><h5 id="4、配置-gitlab-ci-yml文件"><a href="#4、配置-gitlab-ci-yml文件" class="headerlink" title="4、配置.gitlab-ci.yml文件"></a>4、配置.gitlab-ci.yml文件</h5><p>注意：<br>variables:<br>  LC_ALL: “en_US.UTF-8”<br>  LANG: “en_US.UTF-8”<br>  GIT_STRATEGY: fetch #开发阶段这要设置一下，默认每次都会clone代码，耗时较长。上线版本设置为clone获取最新代码</p><p><a href="https://segmentfault.com/a/1190000019540360">持续集成之.gitlab-ci.yml篇（详细讲解了各命令的作用）</a></p><p><a href="https://s0docs0gitlab0com.icopy.site/ce/ci/yaml/README.html">（官方文档）</a> </p><h5 id="原理理解"><a href="#原理理解" class="headerlink" title="原理理解"></a>原理理解</h5><p>在配置.gitlab-ci.yml文件中配置需要执行的脚本，这里配置执行fastlane脚本。</p><h5 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h5><p>个人建议，直接看官方文档，除非英文太差，那就找中文资料吧。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sizeToFit 和 sizeThatFits</title>
    <link href="/2019/10/20/sizeToFit-%E5%92%8C-sizeThatFits/"/>
    <url>/2019/10/20/sizeToFit-%E5%92%8C-sizeThatFits/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h5 id="sizeToFit"><a href="#sizeToFit" class="headerlink" title="sizeToFit"></a>sizeToFit</h5><p>sizeToFit: 会计算出最优的 size 而且会改变自己的size</p><pre><code class="hljs reasonml">UILabel *label = <span class="hljs-literal">[[UIL<span class="hljs-identifier">abel</span> <span class="hljs-identifier">alloc</span>]</span> initWithFrame:<span class="hljs-constructor">CGRectMake(100, 100, 0, 0)</span>];label.backgroundColor = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UIColor</span>.</span></span>grayColor;label.font = <span class="hljs-literal">[UIF<span class="hljs-identifier">ont</span> <span class="hljs-identifier">systemFontOfSize</span>:<span class="hljs-number">20</span>]</span>;label.text = @<span class="hljs-string">&quot;北京欢迎你!!!&quot;</span>;<span class="hljs-comment">//sizeToFit: 直接改变了label的宽和高, 使它根据上面的字符串的大小做合适的改变</span><span class="hljs-literal">[<span class="hljs-identifier">label</span> <span class="hljs-identifier">sizeToFit</span>]</span>;<span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;width = %.0f height = %.0f&quot;</span>,<span class="hljs-params">label</span>.<span class="hljs-params">frame</span>.<span class="hljs-params">size</span>.<span class="hljs-params">width</span>, <span class="hljs-params">label</span>.<span class="hljs-params">frame</span>.<span class="hljs-params">size</span>.<span class="hljs-params">height</span>)</span>;<span class="hljs-literal">[<span class="hljs-identifier">self</span>.<span class="hljs-identifier">view</span> <span class="hljs-identifier">addSubview</span>:<span class="hljs-identifier">label</span>]</span>;<span class="hljs-comment">//输出结果:</span>width = <span class="hljs-number">119</span> height = <span class="hljs-number">24</span>注意: 使用sizeToFit时, 一定要设置控件的frame, 并且不可以使用Masonry, 否则sizeToFit将失效</code></pre><h5 id="sizeThatFits"><a href="#sizeThatFits" class="headerlink" title="sizeThatFits"></a>sizeThatFits</h5><p>sizeThatFits: 会计算出最优的 size 但是不会改变 自己的size</p><pre><code class="hljs reasonml">UILabel *label = <span class="hljs-literal">[[UIL<span class="hljs-identifier">abel</span> <span class="hljs-identifier">alloc</span>]</span> initWithFrame:<span class="hljs-constructor">CGRectMake(100, 100, 0, 0)</span>];label.backgroundColor = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UIColor</span>.</span></span>grayColor;label.font = <span class="hljs-literal">[UIF<span class="hljs-identifier">ont</span> <span class="hljs-identifier">systemFontOfSize</span>:<span class="hljs-number">20</span>]</span>;label.text = @<span class="hljs-string">&quot;北京欢迎你!!!&quot;</span>;<span class="hljs-comment">//sizeThatFits并没有改变原始label的大小</span>CGSize sizeThatFits =  <span class="hljs-literal">[<span class="hljs-identifier">label</span> <span class="hljs-identifier">sizeThatFits</span>:CGS<span class="hljs-identifier">izeZero</span>]</span>;<span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;sizeThatFits: width = %.1f height = %.1f&quot;</span>, <span class="hljs-params">sizeThatFits</span>.<span class="hljs-params">width</span>, <span class="hljs-params">sizeThatFits</span>.<span class="hljs-params">height</span>)</span>;<span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;label: width = %.1f height = %.1f&quot;</span>,<span class="hljs-params">label</span>.<span class="hljs-params">frame</span>.<span class="hljs-params">size</span>.<span class="hljs-params">width</span>, <span class="hljs-params">label</span>.<span class="hljs-params">frame</span>.<span class="hljs-params">size</span>.<span class="hljs-params">height</span>)</span>;<span class="hljs-literal">[<span class="hljs-identifier">self</span>.<span class="hljs-identifier">view</span> <span class="hljs-identifier">addSubview</span>:<span class="hljs-identifier">label</span>]</span>;输出结果:sizeThatFits: width = <span class="hljs-number">119.0</span> height = <span class="hljs-number">24.0</span>label: width = <span class="hljs-number">0.0</span> height = <span class="hljs-number">0.0</span></code></pre><h5 id="iOS-sizeToFit-和-sizeThatFits的联系"><a href="#iOS-sizeToFit-和-sizeThatFits的联系" class="headerlink" title="iOS sizeToFit 和 sizeThatFits的联系"></a>iOS sizeToFit 和 sizeThatFits的联系</h5><p>如果你的控件对尺寸有严格的限定，比如有一个统一的宽高比或者是固定尺寸，那么最好能实现系统给出的约定成俗的接口。<br>sizeToFit 用在基于 frame 布局的情况下，由你的控件去实现 sizeThatFits: 方法：</p><pre><code class="hljs processing">- (CGSize)sizeThatFits:(CGSize)<span class="hljs-built_in">size</span> &#123;    CGSize fitSize = [<span class="hljs-keyword">super</span> sizeThatFits:<span class="hljs-built_in">size</span>];    fitSize.<span class="hljs-built_in">height</span> += self.label.frame.<span class="hljs-built_in">size</span>.<span class="hljs-built_in">height</span>;    <span class="hljs-comment">// 如果是固定尺寸，就像 UISwtich 那样返回一个固定 Size 就 OK 了</span>    <span class="hljs-keyword">return</span> fitSize;&#125;</code></pre><p>然后在外部调用该控件的 sizeToFit 方法，这个方法内部会自动调用 sizeThatFits 并更新自身的 Size：</p><pre><code class="hljs ini"><span class="hljs-section">[self.customView sizeToFit]</span><span class="hljs-comment">; </span></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>刨根问底之 translatesAutoresizingMaskIntoConstraints</title>
    <link href="/2019/10/20/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E4%B9%8B-translatesAutoresizingMaskIntoConstraints/"/>
    <url>/2019/10/20/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E4%B9%8B-translatesAutoresizingMaskIntoConstraints/</url>
    
    <content type="html"><![CDATA[<p>我们查看官方文档，可以看到文档是这样介绍该属性的：</p><pre><code class="hljs scss">它是一个用来决定，是否将视图的自动调整大小的遮罩(autoresizing <span class="hljs-attribute">mask</span>)转换为 <span class="hljs-attribute">Auto</span> Layout 约束的布尔值。</code></pre><p>通过文档介绍我们可以得知：当该属性为 true 时，系统会自动通过视图的 autoresizing mask 创建一组视图的约束，这些约束是基于你提供的 frame、bounds、center 这些属性。也就是说，当你给视图的 frame 赋值之后，它会为你创建静态的、基于 frame 的 Auto Layout 约束。如下：</p><h5 id="属性值为-true且指定-frame"><a href="#属性值为-true且指定-frame" class="headerlink" title="属性值为 true且指定 frame"></a>属性值为 true且指定 frame</h5><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> exampleView = <span class="hljs-constructor">UIView(<span class="hljs-params">frame</span>: CGRect(<span class="hljs-params">x</span>: 100, <span class="hljs-params">y</span>: 100, <span class="hljs-params">width</span>: 100, <span class="hljs-params">height</span>: 100)</span>)<span class="hljs-comment">// 系统根据你指定的frame 给 exampleView 创建静态的 Auto Layout 约束</span>exampleView.backgroundColor = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UIColor</span>.</span></span>greenview.add<span class="hljs-constructor">Subview(<span class="hljs-params">exampleView</span>)</span></code></pre><p>复制代码在上述情况中，你是不能给视图添加额外的约束来修改它的位置或大小的，如果添加额外的约束会导致约束冲突。如下：</p><h5 id="属性值为-true，指定-frame-且添加额外约束"><a href="#属性值为-true，指定-frame-且添加额外约束" class="headerlink" title="属性值为 true，指定 frame 且添加额外约束"></a>属性值为 true，指定 frame 且添加额外约束</h5><pre><code class="hljs less"><span class="hljs-comment">// 例 1-1面的代码下添加此代码，会导致约束冲突</span><span class="hljs-selector-tag">NSLayoutConstraint</span><span class="hljs-selector-class">.activate</span>([    exampleView.widthAnchor.constraint(<span class="hljs-attribute">equalToConstant</span>: <span class="hljs-number">50</span>)    ])</code></pre><p>复制代码错误提示如下图所示：<br><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p3903" alt="3aca4f9fb265f63d5204dcadd60e448a.png"></p><h5 id="添加额外约束导致约束冲突"><a href="#添加额外约束导致约束冲突" class="headerlink" title="添加额外约束导致约束冲突"></a>添加额外约束导致约束冲突</h5><p>如果你想使用 Auto Layout 动态计算、改变视图尺寸的话，你必须将该属性值改为 false 。然后你只需提供无歧义、无冲突的约束即可。如例 1-3 代码所示：<br>例 1-3 属性值为 false</p><pre><code class="hljs reasonml"><span class="hljs-comment">// 布局效果等同于 例 1-1</span><span class="hljs-keyword">let</span> exampleView = <span class="hljs-constructor">UIView(<span class="hljs-params">frame</span>: .<span class="hljs-params">zero</span>)</span>exampleView.backgroundColor = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UIColor</span>.</span></span>greenview.add<span class="hljs-constructor">Subview(<span class="hljs-params">exampleView</span>)</span><span class="hljs-comment">// 使用 Auto Layout 时，务必将此属性值设为 false</span>exampleView.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NSLayoutConstraint</span>.</span></span>activate(<span class="hljs-literal">[</span><span class="hljs-literal">    <span class="hljs-identifier">exampleView</span>.<span class="hljs-identifier">topAnchor</span>.<span class="hljs-identifier">constraint</span>(<span class="hljs-identifier">equalTo</span>: <span class="hljs-identifier">view</span>.<span class="hljs-identifier">topAnchor</span>, <span class="hljs-identifier">constant</span>: <span class="hljs-number">100</span>),</span><span class="hljs-literal">    <span class="hljs-identifier">exampleView</span>.<span class="hljs-identifier">leftAnchor</span>.<span class="hljs-identifier">constraint</span>(<span class="hljs-identifier">equalTo</span>: <span class="hljs-identifier">view</span>.<span class="hljs-identifier">leftAnchor</span>, <span class="hljs-identifier">constant</span>: <span class="hljs-number">100</span>),</span><span class="hljs-literal">    <span class="hljs-identifier">exampleView</span>.<span class="hljs-identifier">widthAnchor</span>.<span class="hljs-identifier">constraint</span>(<span class="hljs-identifier">equalToConstant</span>: <span class="hljs-number">100</span>),</span><span class="hljs-literal">    <span class="hljs-identifier">exampleView</span>.<span class="hljs-identifier">heightAnchor</span>.<span class="hljs-identifier">constraint</span>(<span class="hljs-identifier">equalToConstant</span>: <span class="hljs-number">100</span>)</span><span class="hljs-literal">    ]</span>)</code></pre><p>复制代码当你代码创建视图时，视图的 translatesAutoresizingMaskIntoConstraints 默认为 true，当你使用 Interface Builder 时，系统会自动将 translatesAutoresizingMaskIntoConstraints 的值设为 false。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>代码创建视图时，视图的 translatesAutoresizingMaskIntoConstraints 属性值默认为 true</p><p>Interface Builder 中创建视图时，系统会自动将视图的 translatesAutoresizingMaskIntoConstraints 属性值设为 false</p><p>代码创建的视图，且使用 frame 进行布局时，不能添加额外的约束，会导致约束冲突</p><p>代码创建的视图，且使用 Auto Layout 进行布局时，需将属性值设为 false</p><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://developer.apple.com/documentation/uikit/uiview/1622572-translatesautoresizingmaskintoco">translatesAutoresizingMaskIntoConstraints</a><br><a href="https://stackoverflow.com/questions/47800210/when-should-translatesautoresizingmaskintoconstraints-be-set-to-true">When should translatesAutoresizingMaskIntoConstraints be set to true?</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>UICollectionView间隙问题</title>
    <link href="/2019/10/20/UICollectionView%E9%97%B4%E9%9A%99%E9%97%AE%E9%A2%98/"/>
    <url>/2019/10/20/UICollectionView%E9%97%B4%E9%9A%99%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>func fixSlit(inout rect: CGRect, colCount: CGFloat, space: CGFloat = 0) -&gt; CGFloat {<br>    let totalSpace = (colCount - 1) * space // 总共留出的距离<br>    let itemWidth = (rect.width - totalSpace) / colCount  // 按照真实屏幕算出的cell宽度<br>    let fixValue = 1 / UIScreen.mainScreen().scale （1px=0.5pt,6p为3px=1pt）<br>    var realItemWidth = floor(itemWidth) + fixValue // 取整加fixValue<br>    if realItemWidth &lt; itemWidth { // 有可能原cell宽度小数点后一位大于0.5<br>        realItemWidth += 0.5<br>    }<br>    let realWidth = colCount * realItemWidth + totalSpace // 算出屏幕等分后满足<code>1px=0.5pt</code>实际的宽度<br>    let pointX = (realWidth - rect.width) / 2 // 偏移距离<br>    rect.origin.x = -pointX // 向左偏移<br>    rect.size.width = realWidth<br>    return (rect.width - totalSpace) / colCount // 每个cell真实宽度<br>}</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Universal Links 通用链接</title>
    <link href="/2019/10/20/Universal-Links-%E9%80%9A%E7%94%A8%E9%93%BE%E6%8E%A5/"/>
    <url>/2019/10/20/Universal-Links-%E9%80%9A%E7%94%A8%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>iOS9 之后，才可以支持通用链接。当您支持通用链接时，iOS用户可以点击指向您网站的链接，然后无缝链接到已安装的应用程序，而无需通过Safari。如果未安装您的应用程序，请点击指向您网站的链接以在Safari中打开您的网站。</p><h3 id="通用链接对比自定义URL方案的关键优势。"><a href="#通用链接对比自定义URL方案的关键优势。" class="headerlink" title="通用链接对比自定义URL方案的关键优势。"></a>通用链接对比自定义URL方案的关键优势。</h3><ol><li><code>独特</code>:与自定义URL方案不同，其他应用无法声明通用链接，因为它们使用的是标准的HTTP 或 HTTPS 链接到你的网站。</li><li><code>安全</code>:当用户安装您的应用程序时，iOS会检查您已上传到Web服务器的文件，以确保您的网站允许您的应用程序代表其打开URL。只要您可以创建和上传此文件，因此网站与应用程序的关联是安全的。</li><li><code>灵活</code>:即使未安装您的应用程序，通用链接也可以使用。如果未安装您的应用程序，则按用户期望，点击指向您网站的链接可在Safari中打开内容。</li><li><code>简单</code>:一个URL既适用于您的网站，也适用于您的应用程序。</li><li><code>私人的</code>:其他应用可以与您的应用通信，而无需知道您的应用是否已安装。</li></ol><p>注意：</p><p>通用链接可让用户在点击WKWebView，UIWebView视图和Safari页面中的指向您网站的链接时打开您的应用程序，此外，这些链接还会导致调用openURL:，例如在Mail，Messages和其他应用程序中发生的链接。</p><p>当用户在Safari中浏览您的网站时，他们点击指向当前网页所在域中URL的通用链接，iOS会尊重该用户最有可能的意图并在Safari中打开该链接。如果用户点击指向其他域中URL的通用链接，iOS将在您的应用中打开该链接。</p><p>对于运行9.0之前的iOS版本的用户，点击指向您网站的通用链接可在Safari中打开该链接。</p><h3 id="怎么使用Universal-Links"><a href="#怎么使用Universal-Links" class="headerlink" title="怎么使用Universal Links"></a>怎么使用Universal Links</h3><ol start="0"><li><p>先决条件：你必须有一个域名,且这个域名需要支持https。</p></li><li><p>开启 Associated Domains 域<br><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2356" alt="e9116eb0cfb298c7c4835fbbff6699dd.png"></p></li></ol><p>进入苹果Apple Developer — Member Center - Certificates, Identifiers &amp; Profiles – Identifiers - App IDs –Edit 然后开启打钩 Associated Domains 后保存。</p><ol start="2"><li><p>添加 Associated Domains 域<br> 打开工程配置中的Associated Domains，在其中的Domains中填入你想支持的域名，必须以applinks:为前缀。<img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2357" alt="0f4639afb4a83aead318d1962f43fbda.png"></p></li><li><p>创建一个apple-app-site-association包含有关您的应用程序可以处理的URL的JSON数据的文件。这个文件名必须为apple-app-site-association，没有后缀名.</p></li></ol><p>apple-app-site-association文件:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;applinks&quot;</span>: &#123;        <span class="hljs-attr">&quot;apps&quot;</span>: [],        <span class="hljs-attr">&quot;details&quot;</span>: [            &#123;                <span class="hljs-attr">&quot;appID&quot;</span>: <span class="hljs-string">&quot;9JA89QQLNQ.com.apple.wwdc&quot;</span>,                <span class="hljs-attr">&quot;paths&quot;</span>: [ <span class="hljs-string">&quot;/wwdc/news/&quot;</span>, <span class="hljs-string">&quot;/videos/wwdc/2015/*&quot;</span>]            &#125;,            &#123;                <span class="hljs-attr">&quot;appID&quot;</span>: <span class="hljs-string">&quot;ABCD1234.com.apple.wwdc&quot;</span>,                <span class="hljs-attr">&quot;paths&quot;</span>: [ <span class="hljs-string">&quot;*&quot;</span> ]            &#125;        ]    &#125;&#125;</code></pre><p>appID：组成方式是 teamId.yourapp’s bundle identifier。如上面的 9JA89QQLNQ就是teamId。登陆开发者中心，在Account - Membership里面可以找到Team ID。</p><p>paths：设定你的app支持的路径列表，只有这些指定的路径的链接，才能被app所处理。星号的写法代表了可识别域名下所有链接。</p><ol start="4"><li><p>将apple-app-site-association文件上传到您的HTTPS Web服务器。您可以将文件放置在服务器的根目录或.well-known子目录中. 上传完后,自己先访问一下,看看是否能够获取到，当你在浏览器中输入这个文件链接后，应该是直接下载apple-app-site-association文件。</p></li><li><p>准备您的应用程序以处理通用链接。</p></li><li><p>进入app后的处理<br> 现在用户点击某个链接，直接可以进我们的app了，但是我们的目的是要能够获取到用户进来的链接，根据链接来展示给用户相应的内容。<br>我们需要在工程里的 AppDelegate 里实现方法</p><pre><code class="hljs objectivec">- (<span class="hljs-built_in">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application continueUserActivity:(<span class="hljs-built_in">NSUserActivity</span> *)userActivity restorationHandler:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-built_in">NSArray</span> * _Nullable))restorationHandler&#123;    <span class="hljs-keyword">if</span> ([userActivity.activityType isEqualToString:<span class="hljs-built_in">NSUserActivityTypeBrowsingWeb</span>])    &#123;        <span class="hljs-built_in">NSURL</span> *url = userActivity.webpageURL;        <span class="hljs-keyword">if</span> (url是我们希望处理的)        &#123;            <span class="hljs-comment">//进行我们的处理</span>        &#125;        <span class="hljs-keyword">else</span>        &#123;            [[<span class="hljs-built_in">UIApplication</span> sharedApplication] openURL:url];        &#125;    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;&#125;</code></pre></li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在iOS设备中的备忘录中输入App能识别的链接，然后直接点击此链接，就会直接跳转到你的app了。或是长按，在出现的弹出菜单中第二项是在’XXX’中打开，这也代表着成功：</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2358" alt="fd06b12cf48d7696c55a54b8e89a8a36.png"></p><p>或是你将要测试的网址在safari中打开，在出现的网页上方下滑，可以看到有在”XX”应用中打开：</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2359" alt="7604062dbe0dbbc5a32bbf9465e9dda0.png"></p><p>在微信的网页浏览器中也是可以的，虽然微信屏蔽了所有的scheme方式跳转到其它app，但是Universal Links是由系统直接处理的，微信屏蔽不了，这也就实现了从微信跳转到我们的app。</p><p>苹果为了方便开发者，提供了一个网页来验证我们编写的这个apple-app-site-association是否合法有效，进入<a href="https://link.jianshu.com/?t=https://search.developer.apple.com/appsearch-validation-tool/">验证网址</a>进行验证：</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2360" alt="2594434ea57c0d0fd24e7182f1f15905.png"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>1.apple-app-site-association文件不能带后缀，务必把”.json”的后缀去掉！有些人的电脑是隐藏文件后缀的，这要格外注意；</p><p>2.apple-app-site-association一定要传到域名根目录下；</p><p>3.WebServer需要支持https，且https使用有效的证书（是私密链接）。笔者在这里卡了很久，原因就是后台给配的https使用无效的证书，导致应用安装的时候不能正确的下载apple-app-site-association文件；</p><p>4.如果想测试这个功能，可以让后台搭一个测试服务器，并配置虚拟主机生成域名，然后iOS这边通过host访问域名就可以了。注意”applink:”后面写的一定是域名，不能是IP；</p><p>5.抓包的结果显示，网络顺畅的情况下，应用会在在刚安装（不是打开）的时候会去applink中的地址下载apple-app-site-association文件，所以如果需要测试，请保证网络通畅；</p><p>6.当所有都准备好，需要测试该功能的时候，只需要在记事本或短信中输入App能识别的链接，然后直接点击或是长按就可以了，直接点的效果是跳转到你的App，然后右上角是“去网页”的箭头，长按的效果是弹出的菜单中第二项是“在’XXX’中打开”，这也代表着成功。直接在Safari中输入链接是无效的，必须从一处跳入才可以（比如上一级网页）。</p><p>7.苹果有个网址（这里）可以检测你的apple-app-site-association是否是有效的，准备好了可以测试一下。</p><p>8.测试的时候，建议使用dev证书打包，之后安装到手机上测试功能。未安装应用的情况下直接在手机上跑好像也是可以的，因为抓到过请求。</p><p>9.如果你有问题，但上面没有列出，Stackoverflow上面有个问题，可以看下其他人的建议。 </p><p>10.前端开发经常面临跨域问题，必须要求跨域，如果不跨域，就不行。<br>只有当前webview的url域名，与跳转目标url域名不一致时，Universal Link 才生效。</p><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW1">Apple官方文档</a></p><p><a href="https://www.jianshu.com/p/d1e0c1886046">iOS开发 - Universal Links 通用链接</a></p><p><a href="http://strivingboy.github.io/blog/2015/09/27/ios9/">博客</a></p><p><a href="">WWDC2019内参，小专栏</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS 长连接 socket 股票方向研究</title>
    <link href="/2019/10/20/iOS-%E9%95%BF%E8%BF%9E%E6%8E%A5-socket-%E8%82%A1%E7%A5%A8%E6%96%B9%E5%90%91%E7%A0%94%E7%A9%B6/"/>
    <url>/2019/10/20/iOS-%E9%95%BF%E8%BF%9E%E6%8E%A5-socket-%E8%82%A1%E7%A5%A8%E6%96%B9%E5%90%91%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="网络中进程通信"><a href="#网络中进程通信" class="headerlink" title="网络中进程通信"></a>网络中进程通信</h3><p>在了解socket之前，先了解下网络进程之间如何通信。</p><h5 id="本地进程间通信"><a href="#本地进程间通信" class="headerlink" title="本地进程间通信"></a>本地进程间通信</h5><ol><li>消息传递（管道、消息队列、FIFO）</li><li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li><li>共享内存（匿名的和具名的，eg:channel）</li><li>远程过程调用(RPC)</li></ol><h5 id="网络中进程如何通信"><a href="#网络中进程如何通信" class="headerlink" title="网络中进程如何通信"></a>网络中进程如何通信</h5><p>我们要理解网络中进程如何通信，得解决两个问题：<br>　　ａ、我们要如何标识一台主机，即怎样确定我们将要通信的进程是在那一台主机上运行。<br>　　ｂ、我们要如何标识唯一进程，本地通过pid标识，网络中应该怎样标识？</p><p>解决办法：<br>　　ａ、TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机<br>　　ｂ、传输层的“协议+端口”可以唯一标识主机中的应用程序（进程），因此，我们利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><h5 id="socket是什么"><a href="#socket是什么" class="headerlink" title="socket是什么"></a>socket是什么</h5><p>socket是对TCP/IP协议的封装，它的出现只是使得程序员更方便地使用TCP/IP协议栈而已。socket本身并不是协议，它是应用层与TCP/IP协议族通信的中间软件抽象层，是一组调用接口（TCP/IP网络的API函数）</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2395" alt="dbe646028538d1b1f3890fa8e88b07b9.jpeg"></p><h5 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h5><p>Socket主要是用来解决网络通信的，那么我们就来理解网络中进程是如何通信的。</p><p>Socket编程进行的是端到端的通信，基于网络层和传输层的实现。在网络层，Socket 函数需要指定到底是 IPv4 还是IPv6。传输层需要指定是tcp还是udp。 </p><h5 id="Socket怎么通信"><a href="#Socket怎么通信" class="headerlink" title="Socket怎么通信"></a>Socket怎么通信</h5><p>socket 这个中间件是利用三元组（ip地址，协议，端口）解决网络通信的。</p><h6 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h6><p>通信过程图解：</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2396" alt="7c9b474bf0101675c98b957b6296d83a.jpeg"></p><p>图解说明：</p><p>服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。</p><p>这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p><h6 id="socket中TCP的三次握手建立连接详解"><a href="#socket中TCP的三次握手建立连接详解" class="headerlink" title="socket中TCP的三次握手建立连接详解"></a>socket中TCP的三次握手建立连接详解</h6><p>我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：</p><p>客户端向服务器发送一个SYN J<br>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1<br>客户端再想服务器发一个确认ACK K+1<br>只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？</p><p>三次握手建立连接图解：</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2401" alt="97a37d22000293ba24e53d981d8f3e3e.png"></p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2399" alt="8aa123878e3754db1357220a12cb393c.png"></p><p>三次握手建立连接图解说明：</p><p>当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；<br>服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；<br>客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；<br>服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</p><p>形象比喻：</p><pre><code class="hljs mipsasm">[<span class="hljs-keyword">Shake </span><span class="hljs-number">1</span>] 套接字A：“你好，套接字<span class="hljs-keyword">B，我这里有数据要传送给你，建立连接吧。”</span><span class="hljs-keyword">[Shake </span><span class="hljs-number">2</span>] 套接字<span class="hljs-keyword">B：“好的，我这边已准备就绪。”</span><span class="hljs-keyword">[Shake </span><span class="hljs-number">3</span>] 套接字A：“谢谢你受理我的请求。</code></pre><p>总结：客户端的connect在三次握手的第二次返回，而服务器端的accept在三次握手的第三次返回。</p><h6 id="socket中TCP的四次握手释放连接详解"><a href="#socket中TCP的四次握手释放连接详解" class="headerlink" title="socket中TCP的四次握手释放连接详解"></a>socket中TCP的四次握手释放连接详解</h6><p>socket中的四次握手释放连接的过程</p><p>四次握手释放连接图解：</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2400" alt="214f0d393c12d1ad5061cc76ac1211f2.png"></p><p>四次握手释放连接图解说明：</p><p>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；<br>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；<br>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；<br>接收到这个FIN的源发送端TCP对它进行确认。<br>这样每个方向上都有一个FIN和ACK。</p><p>形象比喻：</p><pre><code class="hljs mipsasm">[<span class="hljs-keyword">Shake </span><span class="hljs-number">1</span>] 套接字A：“任务处理完毕，我希望断开连接。”[<span class="hljs-keyword">Shake </span><span class="hljs-number">2</span>] 套接字<span class="hljs-keyword">B：“哦，是吗？请稍等，我准备一下。”</span><span class="hljs-keyword">等待片刻后……</span><span class="hljs-keyword">[Shake </span><span class="hljs-number">3</span>] 套接字<span class="hljs-keyword">B：“我准备好了，可以断开连接了。”</span><span class="hljs-keyword">[Shake </span><span class="hljs-number">4</span>] 套接字A：“好的，谢谢合作。”</code></pre><h3 id="GCDAsyncSocket"><a href="#GCDAsyncSocket" class="headerlink" title="GCDAsyncSocket"></a>GCDAsyncSocket</h3><h5 id="解决了什么问题-1"><a href="#解决了什么问题-1" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h5><p>CocoaAsyncSocket是谷歌的开发者，基于BSD-Socket写的一个IM框架，它给Mac和iOS提供了易于使用的、强大的异步套接字库，向上封装出简单易用OC接口。省去了我们面向Socket以及数据流Stream等繁琐复杂的编程。 </p><h5 id="二次封装"><a href="#二次封装" class="headerlink" title="二次封装"></a>二次封装</h5><h6 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h6><p>股票类：</p><p>数据量大：5000多支股票，每支股票有分时，分笔数据，画一条k线，可能要500条分时数据，甚至更多。</p><p>实时性：股价每分每秒都在变化，一分钟产生很多条数据，用户要看到最新的信息，真的是一秒钟上下几十万啊。</p><p>服务器主动推：股票预警等等一些重要消息，需要服务器实时推送，保证客户端100%收到，收不到可能造成客户资金损失。</p><p>股票的数据不能通过HTTP协议来传输了，只能走TCP协议了，当然一些个人信息什么的还是走HTTP的。</p><h6 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h6><p>1、数据量比较大：</p><p>一次请求可能返回几百条数据到移动端，对数据要进行压缩，这里采用了 google 的 Protocol Buffer 数据传输格式，因为它对象序列化速度快，压缩率高 (ps: http 一般用 json, xml)。</p><p>2、实时性与主动推：</p><p>服务器与客户端之间维护一条 tcp 长连接，避免每次3次握手，4次挥手，和产生一堆 time_wait 状态的 socket 占用资源。</p><p>走tcp协议需要自己维护一些状态掉线重连，移动端网络情况复杂，有3G，4G，wifi，socket 经常断开，它断了要自动连上，并且还要对应用层透明！不能让应用层感知到！连上后数据接着之前断开的地方发送，不能有影响。</p><p>自动登录，这个是掉线重连后要做的一个操作，不登录拿不到股票数据。登录后接着做一个消息同步，看看有没有新消息。 </p><p>3、客户端100%收到（可靠性）：</p><p>除了 tcp 超时重传和3次ack回应保证了可靠传输之外，我们在app里也实现了一套应用层的ack机制，服务器保存了一组消息，每个消息有个seq号，一个消息推给客户端后，客户端拿到消息的seq，要发ack请求回应服务器这个消息，然后下次服务器才不会推给你，不然的话，下次服务器还是会推给你的。掉线重连，重登录后会同步一次你订阅过的消息，把上次没收到的，或者丢包的消息再同步过来。</p><p>4、客户端的负载均衡（这块demo中没处理）：</p><p>这个一般在服务器做，但后台为防止ip封锁，还有某些服务器不能在全国访问到，所以把负载均衡放在客户端做了，app启动拉取服务器列表，然后多线程并发发送测速包，得到每个服务器延迟和负载，然后选个最优的服务器连上即可，延迟可以理解为路有多长，负载可以理解为路上拥堵情况，显然最短的路不一定是最快的，它可能很堵。</p><p>5、多线程安全问题：</p><p>当多个命令发来的处理，为避免线程安全，将命令包装成task加入队列。<br>我们处理线程一共用了3个串行队列，分别对应任务数组操作队列，任务请求操作队列，数据接收操作队列。队列可以设置标识。</p><p>6、耗电性能等：</p><p>可以在进入后台时断开连接，停止心跳，停止相关操作。进入前台再自动连接开启心跳。</p><h6 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h6><p>1、大致流程 </p><pre><code class="hljs mermaid">graph TDA[开始] --&gt; B(连接)B --&gt; C&#123;是否连接成功&#125;C --&gt;|成功| D[发送心跳命令然后]C --&gt;|失败| E&#123;检查是否可以重连&#125;E --&gt;|成功| B[连接]E --&gt;|失败| G[结束]D --&gt; F[登录]F --&gt; H&#123;是否登录成功&#125;H --&gt;|成功| I[等待发送命令或接受数据]H --&gt;|失败| J[结束]</code></pre><h6 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h6><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@class</span> <span class="hljs-title">HHSocketManager</span>;</span><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">HHSocketDelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span> <span class="hljs-comment">/// socket 收到了响应，errorCode == resp.code</span>- (<span class="hljs-keyword">void</span>)socket:(GCDAsyncSocket *)socket didReceiveResponse:(HHSocketResponse *)resp;<span class="hljs-comment">/// 链接</span>- (<span class="hljs-keyword">void</span>)socket:(GCDAsyncSocket *)socket didConnectToHost:(<span class="hljs-built_in">NSString</span> *)host port:(uint16_t)port;<span class="hljs-comment">/// 断开链接</span>- (<span class="hljs-keyword">void</span>)socketDidDisconnect:(GCDAsyncSocket *)socket withError:(<span class="hljs-built_in">NSError</span> *)err;<span class="hljs-keyword">@end</span> <span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">HHSocketManager</span> : <span class="hljs-title">NSObject</span></span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">weak</span>) <span class="hljs-keyword">id</span> &lt;HHSocketDelegate&gt; delegate;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readonly</span>) HHSocketConfiguration *configuration;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>, <span class="hljs-keyword">readonly</span>) HHSocketStatus socketStatus; - (<span class="hljs-keyword">instancetype</span>)initWithConfiguration:(<span class="hljs-keyword">nonnull</span> HHSocketConfiguration *) configuration;<span class="hljs-comment">//! 是否可以收发数据</span>- (<span class="hljs-built_in">BOOL</span>)avaliable; <span class="hljs-comment">//! 断开 socket 连接</span>- (<span class="hljs-keyword">void</span>)disconnect;<span class="hljs-comment">//! 开始连接</span>- (<span class="hljs-keyword">void</span>)connect;<span class="hljs-comment">//! 发送业务请求（通过command 和 params 包装成request在发送）</span>- (HHSocketRequest *)sendCommand:(<span class="hljs-built_in">UInt16</span>)command params:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSDictionary</span> *)params;<span class="hljs-comment">//! 发送请求</span>- (<span class="hljs-keyword">void</span>)sendRequest:(HHSocketRequest*)request;<span class="hljs-comment">//! 取消所有请求，已发生的将无法取消</span>- (<span class="hljs-keyword">void</span>)cancelRequest:(HHSocketRequest*)request; <span class="hljs-keyword">@end</span></code></pre><h5 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h5><p><a href="https://github.com/Baichenghui/Study/tree/master/GCDAsyncSocketManager">GCDAsyncSocketManager</a></p><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p><a href="https://www.jianshu.com/p/2dbb360886a8">iOS即时通讯，从入门到“放弃”？（这是一个系列）</a>   </p><p><a href="https://www.jianshu.com/p/edb50afa250e">通俗讲解股票类app - TCP网络通信层设计</a></p><p><a href="https://github.com/hehe520/AsyncSocket">AsyncSocket</a></p><p><a href="https://www.jianshu.com/p/6b870f503905">iOS websocket（SocketRocket）</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GCD研究</title>
    <link href="/2019/10/20/GCD%E7%A0%94%E7%A9%B6/"/>
    <url>/2019/10/20/GCD%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务<br>多线程技术可以提高程序的执行效率</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>显示\刷新UI界面、处理UI事件（比如点击事件、滚动事件、拖拽事件等）在主线程执行。</p><p>耗时操作，开启子线程执行。</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行），多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。</p><p>如果线程非常多，CPU会在N多线程之间调度，会消耗大量CPU资源，同时每条线程被调度执行的频次也会会降低（线程的执行效率降低）。<br>因此我们一般只开3-5条线程。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>能适当提高程序的执行效率<br>能适当提高资源利用率（CPU、内存利用率）</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>创建线程是有开销的，iOS下主要成本包括：内核数据结构（大约1KB）、栈空间（子线程512KB、主线程1MB，也可以使用-setStackSize:设置，但必须是4K的倍数，而且最小是16K），创建线程大约需要90毫秒的创建时间<br>如果开启大量的线程，会降低程序的性能，线程越多，CPU在调度线程上的开销就越大。<br>程序设计更加复杂：比如线程之间的通信、多线程的数据共享等问题。</p><h3 id="多线程方案"><a href="#多线程方案" class="headerlink" title="多线程方案"></a>多线程方案</h3><p>在iOS中多线程方案有多中，但最常用的属GCD和NSOperation，然后NSThread、pthread很少使用。本文主要研究GCD这块内容。</p><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><pre><code class="hljs routeros">Grand Central Dispatch (GCD), contains language features, runtime libraries, <span class="hljs-keyword">and</span><span class="hljs-built_in"> system </span>enhancements that provide systemic, comprehensive improvements <span class="hljs-keyword">to</span> the support <span class="hljs-keyword">for</span> concurrent code execution on multicore<span class="hljs-built_in"> hardware </span><span class="hljs-keyword">in</span> macOS, iOS, watchOS, <span class="hljs-keyword">and</span> tvOS.The BSD subsystem, Core Foundation, <span class="hljs-keyword">and</span> Cocoa APIs have all been extended <span class="hljs-keyword">to</span> use these enhancements <span class="hljs-keyword">to</span> help both the<span class="hljs-built_in"> system </span><span class="hljs-keyword">and</span> your application <span class="hljs-keyword">to</span> <span class="hljs-builtin-name">run</span> faster, more efficiently, <span class="hljs-keyword">and</span> with improved responsiveness. Consider how difficult it is <span class="hljs-keyword">for</span> a single application <span class="hljs-keyword">to</span> use multiple cores effectively, let alone <span class="hljs-keyword">to</span> <span class="hljs-keyword">do</span> it on different computers with different numbers of computing cores <span class="hljs-keyword">or</span> <span class="hljs-keyword">in</span> an environment with multiple applications competing <span class="hljs-keyword">for</span> those cores. GCD, operating at the<span class="hljs-built_in"> system </span>level, can better accommodate the needs of all running applications, matching them <span class="hljs-keyword">to</span> the available<span class="hljs-built_in"> system </span>resources <span class="hljs-keyword">in</span> a balanced fashion.</code></pre><p>GCD全称为Grand Central Dispatch，包含语言功能，运行时库和系统增强功能，这些功能提供了系统的，全面的改进，以支持在macOS，iOS，watchOS和tvOS中的多核硬件上并发代码执行的支持。</p><p>BSD子系统，Core Foundation和Cocoa API均已扩展为使用这些增强功能，以帮助系统和您的应用程序更快，更高效地运行，并提高响应速度。单个应用程序有效地使用多个内核很困难，在具有不同数量计算内核的不同计算机上或在多个应用程序竞争那些内核的环境中进行操作就更困难了。在系统级别运行的GCD可以更好地满足所有正在运行的应用程序的需求，并以平衡的方式将它们与可用的系统资源进行匹配。</p><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><h6 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h6><p>让任务串行执行（一个任务执行完毕后，再执行下一个任务）</p><h6 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h6><p>让多个任务并发执行（自动开启多个线程同时执行任务）<br>并发功能只有在异步（dispatch_async）函数下才有效</p><h6 id="dispatch-queue-set-specific"><a href="#dispatch-queue-set-specific" class="headerlink" title="dispatch_queue_set_specific"></a>dispatch_queue_set_specific</h6><p>向指定队列里面设置一个标识</p><p>向queue1对了中设置一个queueKey1标识:</p><pre><code class="hljs reasonml">dispatch<span class="hljs-constructor">_queue_set_specific(<span class="hljs-params">queue1</span>, <span class="hljs-params">queueKey1</span>, &amp;<span class="hljs-params">queueKey1</span>,NULL)</span>;</code></pre><h6 id="dispatch-queue-get-specific"><a href="#dispatch-queue-get-specific" class="headerlink" title="dispatch_queue_get_specific"></a>dispatch_queue_get_specific</h6><p>是获取指定调度队列的上下文键/值数据。</p><pre><code class="hljs objectivec">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * queueKey = <span class="hljs-string">&quot;queueKey&quot;</span>;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * queueKey2 = <span class="hljs-string">&quot;queueKey2&quot;</span>;    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(queueKey, <span class="hljs-literal">NULL</span>);    <span class="hljs-built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(queueKey2, <span class="hljs-literal">NULL</span>);        <span class="hljs-comment">//调用此方法会触发queueFunction函数，留个疑问queueFunction是在什么时候触发？</span>    dispatch_queue_set_specific(queue, queueKey, &amp;queueKey, queueFunction);    dispatch_queue_set_specific(queue2, queueKey2, &amp;queueKey2, <span class="hljs-literal">NULL</span>);        <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;        go();    &#125;);    <span class="hljs-built_in">dispatch_sync</span>(queue2, ^&#123;        go();    &#125;);        <span class="hljs-keyword">if</span> (dispatch_queue_get_specific(queue, queueKey)) &#123;        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;__run in queue&quot;</span>);    &#125;    <span class="hljs-comment">//main queue中找不到queueKey，所以这段Log不会触发，使用dispatch_get_specific(queueKey)的原理也一样</span>    <span class="hljs-keyword">if</span> (dispatch_queue_get_specific(dispatch_get_main_queue(), queueKey)) &#123;        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;__run in main queue&quot;</span>);    &#125;    <span class="hljs-keyword">if</span> (dispatch_get_specific(queueKey)) &#123;        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;__run in main queue&quot;</span>);    &#125;        <span class="hljs-keyword">void</span> go() &#123;    <span class="hljs-comment">//使用dispatch_sync改变了当前的执行队列，所以这里可以检索到queueKey</span>    <span class="hljs-keyword">if</span>(dispatch_get_specific(<span class="hljs-string">&quot;queueKey&quot;</span>)) &#123;        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;queue&quot;</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dispatch_get_specific(<span class="hljs-string">&quot;queueKey2&quot;</span>)) &#123;        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;queue2&quot;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;main queue&quot;</span>);    &#125;&#125;<span class="hljs-keyword">void</span> queueFunction() &#123;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;__queueFunction&quot;</span>);&#125;</code></pre><h6 id="dispatch-get-specific"><a href="#dispatch-get-specific" class="headerlink" title="dispatch_get_specific"></a>dispatch_get_specific</h6><p>在当前队列中取出标识</p><p>注意iOS中线程和队列的关系，所有的动作都是在队列中执行的！</p><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span> <span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[]) &#123;    <span class="hljs-keyword">@autoreleasepool</span> &#123;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *queueKey1 = <span class="hljs-string">&quot;queueKey1&quot;</span>;                <span class="hljs-built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(queueKey1, DISPATCH_QUEUE_SERIAL);        dispatch_queue_set_specific(queue1, queueKey1, &amp;queueKey1, <span class="hljs-literal">NULL</span>);                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1. 当前线程是: %@, 当前队列是: %@ 。&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],dispatch_get_current_queue());                <span class="hljs-keyword">if</span> (dispatch_get_specific(queueKey1)) &#123;            <span class="hljs-comment">//当前队列是主队列，不是queue1队列，所以取不到queueKey1对应的值，故而不执行</span>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2. 当前线程是: %@, 当前队列是: %@ 。&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],dispatch_get_current_queue());            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">1</span>];        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3. 当前线程是: %@, 当前队列是: %@ 。&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],dispatch_get_current_queue());            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">1</span>];        &#125;                <span class="hljs-built_in">dispatch_sync</span>(queue1, ^&#123;            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;4. 当前线程是: %@, 当前队列是: %@ 。&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],dispatch_get_current_queue());            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">1</span>];                        <span class="hljs-keyword">if</span> (dispatch_get_specific(queueKey1)) &#123;                 <span class="hljs-comment">//当前队列是queue1队列，所以能取到queueKey1对应的值，故而执行</span>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;5. 当前线程是: %@, 当前队列是: %@ 。&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],dispatch_get_current_queue());                [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">1</span>];            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;6. 当前线程是: %@, 当前队列是: %@ 。&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],dispatch_get_current_queue());                [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">1</span>];            &#125;        &#125;);        <span class="hljs-built_in">dispatch_async</span>(queue1, ^&#123;            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;7. t当前线程是: %@, 当前队列是: %@ 。&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],dispatch_get_current_queue());            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">1</span>];        &#125;);                [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">5</span>];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>输出结果：</p><pre><code class="hljs apache"><span class="hljs-attribute">2016</span>-<span class="hljs-number">02</span>-<span class="hljs-number">19</span> <span class="hljs-number">14</span>:<span class="hljs-number">31</span>:<span class="hljs-number">23</span>.<span class="hljs-number">390</span> gcd[<span class="hljs-number">96865</span>:<span class="hljs-number">820267</span>] <span class="hljs-number">1</span>.当前线程是: &lt;NSThread: <span class="hljs-number">0</span>x<span class="hljs-number">1001053</span>e<span class="hljs-number">0</span>&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;,当前队列是: &lt;OS_dispatch_queue: com.apple.main-thread[<span class="hljs-number">0</span>x<span class="hljs-number">100059</span>ac<span class="hljs-number">0</span>]&gt;。<span class="hljs-attribute">2016</span>-<span class="hljs-number">02</span>-<span class="hljs-number">19</span> <span class="hljs-number">14</span>:<span class="hljs-number">31</span>:<span class="hljs-number">23</span>.<span class="hljs-number">391</span> gcd[<span class="hljs-number">96865</span>:<span class="hljs-number">820267</span>] <span class="hljs-number">3</span>.当前线程是: &lt;NSThread: <span class="hljs-number">0</span>x<span class="hljs-number">1001053</span>e<span class="hljs-number">0</span>&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;,当前队列是: &lt;OS_dispatch_queue: com.apple.main-thread[<span class="hljs-number">0</span>x<span class="hljs-number">100059</span>ac<span class="hljs-number">0</span>]&gt;。<span class="hljs-attribute">2016</span>-<span class="hljs-number">02</span>-<span class="hljs-number">19</span> <span class="hljs-number">14</span>:<span class="hljs-number">31</span>:<span class="hljs-number">24</span>.<span class="hljs-number">396</span> gcd[<span class="hljs-number">96865</span>:<span class="hljs-number">820267</span>] <span class="hljs-number">4</span>.当前线程是: &lt;NSThread: <span class="hljs-number">0</span>x<span class="hljs-number">1001053</span>e<span class="hljs-number">0</span>&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;,当前队列是: &lt;OS_dispatch_queue: queueKey<span class="hljs-number">1</span>[<span class="hljs-number">0</span>x<span class="hljs-number">103000000</span>]&gt;。<span class="hljs-attribute">2016</span>-<span class="hljs-number">02</span>-<span class="hljs-number">19</span> <span class="hljs-number">14</span>:<span class="hljs-number">31</span>:<span class="hljs-number">25</span>.<span class="hljs-number">400</span> gcd[<span class="hljs-number">96865</span>:<span class="hljs-number">820267</span>] <span class="hljs-number">5</span>.当前线程是: &lt;NSThread: <span class="hljs-number">0</span>x<span class="hljs-number">1001053</span>e<span class="hljs-number">0</span>&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;,当前队列是: &lt;OS_dispatch_queue: queueKey<span class="hljs-number">1</span>[<span class="hljs-number">0</span>x<span class="hljs-number">103000000</span>]&gt;。<span class="hljs-attribute">2016</span>-<span class="hljs-number">02</span>-<span class="hljs-number">19</span> <span class="hljs-number">14</span>:<span class="hljs-number">31</span>:<span class="hljs-number">26</span>.<span class="hljs-number">402</span> gcd[<span class="hljs-number">96865</span>:<span class="hljs-number">820367</span>] <span class="hljs-number">7</span>. t当前线程是: &lt;NSThread: <span class="hljs-number">0</span>x<span class="hljs-number">100105</span>e<span class="hljs-number">10</span>&gt;&#123;number = <span class="hljs-number">2</span>, name = (null)&#125;,当前队列是: &lt;OS_dispatch_queue: queueKey<span class="hljs-number">1</span>[<span class="hljs-number">0</span>x<span class="hljs-number">103000000</span>]&gt;。<span class="hljs-attribute">Program</span> ended with exit code: <span class="hljs-number">0</span></code></pre><h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><h6 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h6><p>在当前线程中执行任务，不具备开启新线程的能力。</p><p>注意：使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）</p><p>demo：</p><p>无论怎样都不会开启新线程</p><pre><code class="hljs objectivec"><span class="hljs-comment">/*</span><span class="hljs-comment"> 同步+并发  不会开启新线程，依旧在当前线程执行任务</span><span class="hljs-comment"> */</span>- (<span class="hljs-keyword">void</span>)test3 &#123;    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;syncConcrrent&quot;</span>, DISPATCH_QUEUE_CONCURRENT);    <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1 %@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);    &#125;);        <span class="hljs-comment">/*</span><span class="hljs-comment">     2019-12-20 16:22:30.890416+0800 threadDemo[30526:6608103] 1 &lt;NSThread: 0x600001b9c680&gt;&#123;number = 1, name = main&#125;</span><span class="hljs-comment">     */</span>&#125;</code></pre><p>线程死锁</p><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)test1 &#123;    <span class="hljs-comment">// dispatch_async 开启的新线程，在队列 queue 中 ，往queue队列添加同步任务执行，线程卡死</span>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;asyncSerial&quot;</span>, DISPATCH_QUEUE_SERIAL);         <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;         <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;test1 start%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);        <span class="hljs-comment">//Thread 3: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)</span>        <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;test1 %@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);        &#125;);                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;test1 end%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);    &#125;);        <span class="hljs-comment">/*</span><span class="hljs-comment">     2019-12-20 09:56:54.932893+0800 threadDemo[11409:6405262] test1 start&lt;NSThread: 0x600002235e40&gt;&#123;number = 5, name = (null)&#125;</span><span class="hljs-comment">     </span><span class="hljs-comment">     只打印了第一条。后面出现线程死锁了。</span><span class="hljs-comment">     </span><span class="hljs-comment">     卡住原因：</span><span class="hljs-comment">        1、串行队列，任务需要一个任务执行完毕接着下一个才执行</span><span class="hljs-comment">        2、现在队列queue要执行 dispatch_sync 函数添加一个同步任务block</span><span class="hljs-comment">        3、dispatch_sync 是同步的，需要将添加的任务block立即执行</span><span class="hljs-comment">        4、此时调用 dispatch_sync 函数所在线程处于等待状态，需要block任务执行才继续往后执行，而执行 dispatch_sync 函数的线程与block执行所在线程是同一个线程，所以这个线程一直处于等待状态。不会往后执行，也不会执行block。</span><span class="hljs-comment">     */</span>&#125;``` YYKit库中应用</code></pre><p>/**<br> YYKit库中，在SDWebImage中也有类似的应用</p><p> 用于确保任务在主线程下执行<br> */<br>static inline void _yy_dispatch_sync_on_main_queue(void (^block)(void)) {<br>    if (pthread_main_np()) {<br>        block();<br>    } else {<br>        dispatch_sync(dispatch_get_main_queue(), block);<br>    }<br>}</p><pre><code class="hljs plain">AFNetworking库中应用</code></pre><p>/**<br> AFNetworking库中</p><p> AFURLSessionManager 中session创建时用到：<br>    由于session创建在iOS8之前是线程不安全的，所以使用同步+串行队列实现锁的功能</p><p> 注意：当前队列与同步函数中任务的队列不是一个队列<br> */<br>//    static void url_session_manager_create_task_safely(dispatch_block_t block) {<br>//        if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) {<br>//            // Fix of bug<br>//            // Open Radar:<a href="http://openradar.appspot.com/radar?id=5871104061079552">http://openradar.appspot.com/radar?id=5871104061079552</a> (status: Fixed in iOS8)<br>//            // Issue about:<a href="https://github.com/AFNetworking/AFNetworking/issues/2093">https://github.com/AFNetworking/AFNetworking/issues/2093</a><br>//            dispatch_sync(url_session_manager_creation_queue(), block);<br>//        } else {<br>//            block();<br>//        }<br>//    }</p><pre><code class="hljs clean">###### 异步在新的线程中执行任务，具备开启新线程的能力demo:在主队列，异步执行任务，不会开启新线程</code></pre><ul><li><p>(void)test1 {<br>  dispatch_queue_t queue = dispatch_get_main_queue();</p><p>  dispatch_async(queue, ^{ NSLog(@”1 %@”, [NSThread currentThread]); });<br>  dispatch_async(queue, ^{ NSLog(@”2 %@”, [NSThread currentThread]); });<br>  dispatch_async(queue, ^{ NSLog(@”3 %@”, [NSThread currentThread]); });</p><p>  /**</p><pre><code>  2019-12-18 11:50:33.358149+0800 threadDemo[4613:5504490] 1 &lt;NSThread: 0x600001cde1c0&gt;&#123;number = 1, name = main&#125;  2019-12-18 11:50:33.358549+0800 threadDemo[4613:5504490] 2 &lt;NSThread: 0x600001cde1c0&gt;&#123;number = 1, name = main&#125;  2019-12-18 11:50:33.358696+0800 threadDemo[4613:5504490] 3 &lt;NSThread: 0x600001cde1c0&gt;&#123;number = 1, name = main&#125;</code></pre><p>   */<br>}</p></li></ul><pre><code class="hljs plain">除主队列外，异步执行任务，都会开启新线程</code></pre><ul><li><p>(void)test2 {<br>  dispatch_queue_t queue1= dispatch_queue_create(“asyncSerial”, DISPATCH_QUEUE_SERIAL);<br>  dispatch_async(queue1, ^{ NSLog(@”1-1 %@”, [NSThread currentThread]); });<br>  dispatch_async(queue1, ^{ NSLog(@”1-2 %@”, [NSThread currentThread]); });<br>  dispatch_async(queue1, ^{ NSLog(@”1-3 %@”, [NSThread currentThread]); });</p><p>  /**</p><pre><code>  2019-12-18 11:53:59.972777+0800 threadDemo[4656:5507191] 1 &lt;NSThread: 0x6000012fd380&gt;&#123;number = 3, name = (null)&#125;  2019-12-18 11:53:59.973284+0800 threadDemo[4656:5507191] 2 &lt;NSThread: 0x6000012fd380&gt;&#123;number = 3, name = (null)&#125;  2019-12-18 11:53:59.973437+0800 threadDemo[4656:5507191] 3 &lt;NSThread: 0x6000012fd380&gt;&#123;number = 3, name = (null)&#125;</code></pre><p>   */</p></li></ul><p>//    dispatch_queue_t queue2 = dispatch_queue_create(“asyncConcurrent”, DISPATCH_QUEUE_CONCURRENT);<br>//    dispatch_async(queue2, ^{ NSLog(@”2-1 %@”, [NSThread currentThread]); });<br>//    dispatch_async(queue2, ^{ NSLog(@”2-2 %@”, [NSThread currentThread]); });<br>//    dispatch_async(queue2, ^{ NSLog(@”2-3 %@”, [NSThread currentThread]); });</p><pre><code>/** 2019-12-18 11:57:09.136050+0800 threadDemo[4686:5509014] 2-2 &lt;NSThread: 0x600002350000&gt;&#123;number = 6, name = (null)&#125; 2019-12-18 11:57:09.136154+0800 threadDemo[4686:5509013] 2-1 &lt;NSThread: 0x60000237bd00&gt;&#123;number = 5, name = (null)&#125; 2019-12-18 11:57:09.136174+0800 threadDemo[4686:5509015] 2-3 &lt;NSThread: 0x60000237b480&gt;&#123;number = 4, name = (null)&#125; */</code></pre><p>}</p><pre><code class="hljs clean">##### Dispatch Group[参考](https:<span class="hljs-comment">//xiaozhuanlan.com/topic/0863519247)</span> dispatch_group可以将GCD的任务合并到一个组里来管理，也可以同时监听组里所有任务的执行情况。    ###### dispatch_group_create本质是一个初始value为LONG_MAX的semaphore，通过信号量来实现一组任务的管理，代码如下：</code></pre><p>dispatch_group_t dispatch_group_create(void) {<br>    //申请内存空间<br>    dispatch_group_t dg = (dispatch_group_t)_dispatch_alloc(<br>            DISPATCH_VTABLE(group), sizeof(struct dispatch_semaphore_s));<br>    //使用LONG_MAX初始化信号量结构体<br>    _dispatch_semaphore_init(LONG_MAX, dg);<br>    return dg;<br>}</p><pre><code class="hljs clean">###### dispatch_group_async 加入组的任务异步执行 ###### dispatch_group_enter / leave dispatch_group_enter的逻辑是将dispatch_group_t转换成dispatch_semaphore_t后将dsema_value的值减一。 应用注意：<span class="hljs-number">1</span>、dispatch_group_enter必须在dispatch_group_leave之前出现<span class="hljs-number">2</span>、dispatch_group_enter和dispatch_group_leave必须成对出现demo：</code></pre><ul><li>(void)test1 {<br>  NSLog(@”1:%@”,[NSThread currentThread]);<br>  dispatch_group_t group = dispatch_group_create();<br>  dispatch_queue_t queue = dispatch_queue_create(“concurrentQueue”, DISPATCH_QUEUE_CONCURRENT);</li></ul><p>//    //注意不要放在这,而应该放在dispatch_group_enter / leave 最后面。<br>//    //否则可额能计数不对，导致提前回调<br>//    dispatch_group_notify(group, queue, ^{<br>//            NSLog(@”2”);<br>//    });</p><pre><code>dispatch_group_enter(group);dispatch_async(queue, ^&#123;    sleep(1);    NSLog(@&quot;3:%@&quot;,[NSThread currentThread]);    dispatch_group_leave(group);&#125;);dispatch_group_enter(group);dispatch_async(queue, ^&#123;    sleep(3);    NSLog(@&quot;4:%@&quot;,[NSThread currentThread]);    dispatch_group_leave(group);&#125;);dispatch_group_notify(group, queue, ^&#123;        NSLog(@&quot;2:%@&quot;,[NSThread currentThread]);&#125;);NSLog(@&quot;5:%@&quot;,[NSThread currentThread]);/**2019-12-18 16:03:42.575564+0800 threadDemo[5518:5610267] 1:&lt;NSThread: 0x600001c085c0&gt;&#123;number = 1, name = main&#125;2019-12-18 16:03:42.576226+0800 threadDemo[5518:5610267] 5:&lt;NSThread: 0x600001c085c0&gt;&#123;number = 1, name = main&#125;2019-12-18 16:03:43.578856+0800 threadDemo[5518:5610368] 3:&lt;NSThread: 0x600001c4ffc0&gt;&#123;number = 4, name = (null)&#125;2019-12-18 16:03:45.579819+0800 threadDemo[5518:5610366] 4:&lt;NSThread: 0x600001c4b580&gt;&#123;number = 6, name = (null)&#125;2019-12-18 16:03:45.580037+0800 threadDemo[5518:5610366] 2:&lt;NSThread: 0x600001c4b580&gt;&#123;number = 6, name = (null)&#125;*/</code></pre><p>}</p><pre><code class="hljs clean">###### dispatch_group_wait同步等待，直到group里面的block全部执行完毕，才会继续往后执行。需要注意下 dispatch_group_wait 的位置，不能放在任务添加之前。demo:</code></pre><ul><li><p>(void)test3 {<br>  dispatch_queue_t aDQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>  dispatch_group_t group = dispatch_group_create();<br>  // Add a task to the group<br>  dispatch_group_async(group, aDQueue, ^{</p><pre><code>  sleep(2);  printf(&quot;task 1 \n&quot;);</code></pre><p>  });<br>  dispatch_group_async(group, aDQueue, ^{</p><pre><code>  printf(&quot;task 2 \n&quot;);</code></pre><p>  });</p><p>  printf(“wait 1 2 \n”);<br>  //同步等待，直到group里面的block全部执行完毕，才会继续往后执行。<br>  dispatch_group_wait(group, DISPATCH_TIME_FOREVER);<br>  printf(“task 1 2 finished \n”);</p><p>  /**</p><pre><code>  wait 1 2  task 2  task 1  task 1 2 finished</code></pre><p>  */<br>}</p><pre><code class="hljs clean">###### dispatch_group_notify队列组拦截通知模块(内部本身是异步执行的,不会阻塞线程) 需要注意下 dispatch_group_notify 的位置，不能放在任务添加之前。demo:</code></pre></li><li><p>(void)test2 {<br>  NSLog(@”1:%@”,[NSThread currentThread]);<br>  // 创建队列<br>  dispatch_queue_t queue = dispatch_get_global_queue(0, 0);<br>  // 创建队列组<br>  dispatch_group_t group = dispatch_group_create();</p><p>  /*<br>  // 不要写在这，没意义，我们都知道他在组内所有的任务执行完毕会调用 dispatch_group_notify 中的回调块。<br>  // 但是后面还有一句，当组内没有任务时，dispatch_group_notify 中的回调块也会立即执行。<br>  // 队列组拦截通知模块(内部本身是异步执行的,不会阻塞线程)<br>  dispatch_group_notify(group, queue, ^{</p><pre><code>  NSLog(@&quot;4:%@&quot;,[NSThread currentThread]);</code></pre><p>  });</p><p>  2019-12-18 16:07:54.677923+0800 threadDemo[5581:5613688] 1:&lt;NSThread: 0x6000035c57c0&gt;{number = 1, name = main}<br>  2019-12-18 16:07:54.678160+0800 threadDemo[5581:5613816] 4:&lt;NSThread: 0x600003595cc0&gt;{number = 6, name = (null)}<br>  2019-12-18 16:07:55.678663+0800 threadDemo[5581:5613688] 5:&lt;NSThread: 0x6000035c57c0&gt;{number = 1, name = main}<br>  2019-12-18 16:07:56.681079+0800 threadDemo[5581:5613812] 2:&lt;NSThread: 0x6000035995c0&gt;{number = 5, name = (null)}<br>  2019-12-18 16:07:57.680645+0800 threadDemo[5581:5613815] 3:&lt;NSThread: 0x60000359f300&gt;{number = 3, name = (null)}<br>  */</p><p>  //队列组异步执行任务<br>  dispatch_group_async(group, queue, ^{</p><pre><code>  sleep(2);  NSLog(@&quot;2:%@&quot;,[NSThread currentThread]);</code></pre><p>  });<br>  dispatch_group_async(group, queue, ^{</p><pre><code>  sleep(3);  NSLog(@&quot;3:%@&quot;,[NSThread currentThread]);</code></pre><p>  });<br>  // 队列组拦截通知模块(内部本身是异步执行的,不会阻塞线程)<br>  dispatch_group_notify(group, queue, ^{</p><pre><code>  NSLog(@&quot;4:%@&quot;,[NSThread currentThread]);</code></pre><p>  });</p><p>  sleep(1);<br>  NSLog(@”5:%@”,[NSThread currentThread]);</p><p>  /*<br>   2019-12-18 16:06:55.380553+0800 threadDemo[5558:5612492] 1:&lt;NSThread: 0x600003d60800&gt;{number = 1, name = main}<br>   2019-12-18 16:06:56.381177+0800 threadDemo[5558:5612492] 5:&lt;NSThread: 0x600003d60800&gt;{number = 1, name = main}<br>   2019-12-18 16:06:57.384415+0800 threadDemo[5558:5612611] 2:&lt;NSThread: 0x600003d30380&gt;{number = 5, name = (null)}<br>   2019-12-18 16:06:58.385496+0800 threadDemo[5558:5612614] 3:&lt;NSThread: 0x600003d351c0&gt;{number = 3, name = (null)}<br>   2019-12-18 16:06:58.385737+0800 threadDemo[5558:5612614] 4:&lt;NSThread: 0x600003d351c0&gt;{number = 3, name = (null)}<br>   */<br>}</p><pre><code class="hljs clean">##### dispatch_block[dispatch_block](https:<span class="hljs-comment">//www.cnblogs.com/KobeLuo/p/6464233.html)</span>[dispatch_block](https:<span class="hljs-comment">//www.jianshu.com/p/5a16dfd36fad)</span>##### dispatch_semaphore 信号量，有三个方法：  ###### dispatch_semaphore_createdispatch_semaphore_t dispatch_semaphore_create(long value);    创建一个信号量，信号量的值为入参 value###### dispatch_semaphore_waitlong dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);    接收一个信号和时间值，若信号的信号量为<span class="hljs-number">0</span>，则会阻塞当前线程，直到信号量大于<span class="hljs-number">0</span>或者经过输入的时间值；    若信号量大于<span class="hljs-number">0</span>，则会使信号量减<span class="hljs-number">1</span>并返回，程序继续住下执行###### dispatch_semaphore_signallong dispatch_semaphore_signal(dispatch_semaphore_t dsema);    接收一个信号量，发送信号使信号量的值 +<span class="hljs-number">1</span>并返回 ###### 使用应用场景：<span class="hljs-number">1.</span> 充当锁的功能<span class="hljs-number">2.</span> 异步任务，同步返回（同步获取指定APP在AppStore中的当前版本）<span class="hljs-number">3.</span> 并发控制（实现与NSOperationQueue中max-ConcurrentOperationCount 类似功能。）demo:并发控制</code></pre><p>@implementation SemaphoreMaxConcurrentCount {<br>  dispatch_semaphore_t _semaphore;<br>  dispatch_queue_t _queue;<br>}</p></li><li><p>(instancetype)init {<br>  return [self initWithMaxConcurrentCount:3];;<br>}</p></li><li><p>(instancetype)initWithMaxConcurrentCount:(NSInteger)count {<br>  if (self = [super init]) {</p><pre><code>  if (count &lt; 1) &#123;      count = 3;  &#125;  _semaphore = dispatch_semaphore_create(count);  _queue = dispatch_queue_create(&quot;asyncConcurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</code></pre><p>  }<br>  return self;<br>}</p></li></ul><ul><li>(void)addTask:(TaskBlock)block {<br>  dispatch_async(_queue, ^{<pre><code>  dispatch_semaphore_wait(self-&gt;_semaphore, DISPATCH_TIME_FOREVER);  dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;      block();      dispatch_semaphore_signal(self-&gt;_semaphore);  &#125;);</code></pre>  });<br>}</li></ul><p>@end</p><pre><code class="hljs plain">AFNetworking库中</code></pre><p>/**<br> AFNetworking库中</p><p> 获取session中完成的tasks。这个 与 <code>appVersionInAppStore:</code> 方法中的作用差不多。</p><p> 都是通过block获取数据，然后将数据直接返回出去，避免了其他地方获取task也要用回调的方式获取数据。</p><p> */<br>//- (NSArray *)tasksForKeyPath:(NSString *)keyPath {<br>//    __block NSArray *tasks = nil;<br>//    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);<br>//    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {<br>//        if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) {<br>//            tasks = dataTasks;<br>//        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) {<br>//            tasks = uploadTasks;<br>//        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) {<br>//            tasks = downloadTasks;<br>//        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) {<br>//            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@”@unionOfArrays.self”];<br>//        }<br>//<br>//        dispatch_semaphore_signal(semaphore);<br>//    }];<br>//<br>//    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>//<br>//    return tasks;<br>//}</p><pre><code class="hljs plain">充当锁的功能</code></pre><p>/**<br> 充当锁的功能</p><p> 当线程1执行到dispatch_semaphore_wait这一行时，semaphore的信号量为1，所以使信号量-1变为0，并且线程1继续往下执行；<br> 当在线程1NSLog这一行代码还没执行完的时候，又有线程2来访问，执行dispatch_semaphore_wait时由于此时信号量为0，且时间为DISPATCH_TIME_FOREVER,所以会一直阻塞线程2（此时线程2处于等待状态），直到线程1执行完NSLog并执行完dispatch_semaphore_signal使信号量为1后，线程2才能解除阻塞继续住下执行。<br> 这就可以保证同时只有一个线程执行NSLog这一行代码。</p><p> */</p><ul><li><p>(void)test1 {<br>  dispatch_queue_t queue = dispatch_get_global_queue(0, 0);<br>  dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);<br>  for (int i = 0; i &lt; 100; i++) {</p><pre><code>  dispatch_async(queue, ^&#123;      // 相当于加锁      dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);      NSLog(@&quot;i = %d semaphore = %@&quot;, i, semaphore);      // 相当于解锁      dispatch_semaphore_signal(semaphore);  &#125;);</code></pre><p>  }<br>}</p><pre><code class="hljs gcode">异步任务，同步返回<span class="hljs-comment">(同步获取指定APP在AppStore中的当前版本)</span></code></pre><p>/**<br>异步任务，同步返回</p><p>同步获取指定APP在AppStore中的当前版本<br>*/</p></li><li><p>(NSString *)appVersionInAppStore:(NSString *)appId {<br>  __block NSString *appVersion = @””;<br>  NSString *url = [NSString stringWithFormat:@”<a href="https://itunes.apple.com/lookup?id=%25@&quot;,appId%5D">https://itunes.apple.com/lookup?id=%@&quot;,appId]</a>;<br>  NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:url]];</p><p>  dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</p><p>  NSURLSessionDataTask *dataTask = [[NSURLSession sharedSession] dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {</p><pre><code>  NSError *err;  NSDictionary *jsonData = [NSJSONSerialization JSONObjectWithData:data options:(NSJSONReadingMutableContainers) error:&amp;err];  if (!err) &#123;      NSArray *results = jsonData[@&quot;results&quot;];      if ([results isKindOfClass:[NSArray class]] &amp;&amp; results != nil &amp;&amp; results.count &gt; 0) &#123;          appVersion = results.firstObject[@&quot;version&quot;];      &#125;  &#125;  dispatch_semaphore_signal(semaphore);</code></pre><p>  }];</p><p>  [dataTask resume];</p><p>  dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</p><p>  return appVersion;</p><pre><code class="hljs mipsasm"><span class="hljs-comment">##### dispatch_barrier</span> 在一个并行队列中，有多个线程在执行多个任务，在这个并行队列中，有一个<span class="hljs-keyword">dispatch_barrier任务。这样会使所有在这个dispatch_barrier之后的任务总会等待barrier之前的所有任务结束之后，才会执行。</span><span class="hljs-keyword"></span><span class="hljs-keyword">dispatch_barrier </span>又分为 <span class="hljs-keyword">dispatch_barrier_sync </span>和 <span class="hljs-keyword">dispatch_barrier_async</span><span class="hljs-keyword"></span><span class="hljs-keyword">注意：</span><span class="hljs-keyword">1.barrier和串行队列配合是完全没有意义的。</span><span class="hljs-keyword">barrier的目的是为了在某种情况下，同一个队列中一些并发任务必须在另一些并发任务之后执行，所以需要一个类似于拦截的功能，迫使后执”</span><span class="hljs-keyword">“行的任务必须等待。那么，串行队列中的所有任务本身就是按照顺序执行的。</span><span class="hljs-keyword"></span><span class="hljs-keyword">2.在global </span>queue中使用<span class="hljs-keyword">barrier没有意义。</span><span class="hljs-keyword">barrier实现的基本条件是，要写在同一队列中。举个例子，你现在创建了两个并行队列，你在其中一个队列中插入了一个barrier任务，那么你不可能期待他可以在第二个队列中生效，对吧。同样的，每一次使用global </span>queue，系统分配给你的可能是不同的并行队列，你在其中插入一个<span class="hljs-keyword">barrier任务，没有意义。</span><span class="hljs-keyword"></span><span class="hljs-keyword">###### </span><span class="hljs-keyword">dispatch_barrier_sync</span><span class="hljs-keyword"></span><span class="hljs-keyword">dispatch_barrier_sync </span>中的任务同步执行，会阻塞当前线程<span class="hljs-symbol">demo:</span></code></pre></li><li><p>(void)test1 {<br>  dispatch_queue_t queue = dispatch_queue_create(“asyncConcurrent”, DISPATCH_QUEUE_CONCURRENT);</p><p>  for (int i = 0; i &lt; 10; i++) {</p><pre><code>  if (i % 2 == 0) &#123;      dispatch_async(queue, ^&#123;          sleep(1);          NSLog(@&quot;dispatch_barrier_sync 之前的任务:%d&quot;,i);      &#125;);  &#125;  else &#123;      dispatch_async(queue, ^&#123;          NSLog(@&quot;dispatch_barrier_sync 之前的任务:%d&quot;,i);      &#125;);  &#125;</code></pre><p>  }</p><p>  dispatch_barrier_sync(queue, ^{</p><pre><code>  NSLog(@&quot;dispatch_barrier_sync 任务执行 %@&quot;, [NSThread currentThread]);</code></pre><p>  });</p><p>  NSLog(@”dispatch_barrier_sync 所在线程 %@”, [NSThread currentThread]);</p><p>  for (int i = 0; i &lt; 10; i++) {</p><pre><code>  if (i % 2 == 0) &#123;      dispatch_async(queue, ^&#123;          sleep(1);          NSLog(@&quot;dispatch_barrier_sync 之后的任务:%d&quot;,i);      &#125;);  &#125;  else &#123;      dispatch_async(queue, ^&#123;          NSLog(@&quot;dispatch_barrier_sync 之后的任务:%d&quot;,i);      &#125;);  &#125;</code></pre><p>  }</p><p>  /**<br>   2019-12-19 13:41:20.335598+0800 threadDemo[8655:6043711] dispatch_barrier_sync 之前的任务:1<br>   2019-12-19 13:41:20.335702+0800 threadDemo[8655:6044001] dispatch_barrier_sync 之前的任务:3<br>   2019-12-19 13:41:20.336030+0800 threadDemo[8655:6044003] dispatch_barrier_sync 之前的任务:5<br>   2019-12-19 13:41:20.336205+0800 threadDemo[8655:6044004] dispatch_barrier_sync 之前的任务:7<br>   2019-12-19 13:41:20.336373+0800 threadDemo[8655:6044005] dispatch_barrier_sync 之前的任务:9<br>   2019-12-19 13:41:21.340593+0800 threadDemo[8655:6043711] dispatch_barrier_sync 之前的任务:6<br>   2019-12-19 13:41:21.340593+0800 threadDemo[8655:6043998] dispatch_barrier_sync 之前的任务:0<br>   2019-12-19 13:41:21.340593+0800 threadDemo[8655:6044001] dispatch_barrier_sync 之前的任务:8<br>   2019-12-19 13:41:21.340593+0800 threadDemo[8655:6044002] dispatch_barrier_sync 之前的任务:4<br>   2019-12-19 13:41:21.340636+0800 threadDemo[8655:6044000] dispatch_barrier_sync 之前的任务:2<br>   2019-12-19 13:41:21.340931+0800 threadDemo[8655:6043503] dispatch_barrier_sync 任务执行 &lt;NSThread: 0x6000014820c0&gt;{number = 1, name = main}<br>   2019-12-19 13:41:21.341159+0800 threadDemo[8655:6043503] dispatch_barrier_sync 所在线程 &lt;NSThread: 0x6000014820c0&gt;{number = 1, name = main}<br>   2019-12-19 13:41:21.341339+0800 threadDemo[8655:6044002] dispatch_barrier_sync 之后的任务:1<br>   2019-12-19 13:41:21.341552+0800 threadDemo[8655:6043998] dispatch_barrier_sync 之后的任务:3<br>   2019-12-19 13:41:21.342288+0800 threadDemo[8655:6044002] dispatch_barrier_sync 之后的任务:5<br>   2019-12-19 13:41:21.342807+0800 threadDemo[8655:6044004] dispatch_barrier_sync 之后的任务:7<br>   2019-12-19 13:41:21.342890+0800 threadDemo[8655:6043711] dispatch_barrier_sync 之后的任务:9<br>   2019-12-19 13:41:22.345189+0800 threadDemo[8655:6044001] dispatch_barrier_sync 之后的任务:2<br>   2019-12-19 13:41:22.345189+0800 threadDemo[8655:6044005] dispatch_barrier_sync 之后的任务:4<br>   2019-12-19 13:41:22.345227+0800 threadDemo[8655:6044003] dispatch_barrier_sync 之后的任务:6<br>   2019-12-19 13:41:22.345227+0800 threadDemo[8655:6044000] dispatch_barrier_sync 之后的任务:0<br>   2019-12-19 13:41:22.345237+0800 threadDemo[8655:6043998] dispatch_barrier_sync 之后的任务:8<br>   */<br>}</p><pre><code class="hljs dns">###### dispatch_barrier_async dispatch_barrier_async 中的任务异步执行，不会阻塞当前线程demo:``` - (void)test2 &#123;    dispatch_queue_t queue = dispatch_queue_create(&quot;asyncConcurrent&quot;, DISPATCH_QUEUE_CONCURRENT)<span class="hljs-comment">;</span>        for (int i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 10; i++) &#123;</span>        if (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;            dispatch_async(queue, ^&#123;                sleep(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span>                NSLog(@&quot;dispatch_barrier_sync 之前的任务:%d&quot;,i)<span class="hljs-comment">;</span>            &#125;)<span class="hljs-comment">;</span>        &#125;        else &#123;            dispatch_async(queue, ^&#123;                NSLog(@&quot;dispatch_barrier_sync 之前的任务:%d&quot;,i)<span class="hljs-comment">;</span>            &#125;)<span class="hljs-comment">;</span>        &#125;    &#125;        dispatch_barrier_async(queue, ^&#123;        NSLog(@&quot;dispatch_barrier_sync 任务执行 %@&quot;, [NSThread currentThread])<span class="hljs-comment">;</span>    &#125;)<span class="hljs-comment">;</span>        NSLog(@&quot;dispatch_barrier_async 所在线程 %@&quot;, [NSThread currentThread])<span class="hljs-comment">;</span>        for (int i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 10; i++) &#123;</span>        if (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;            dispatch_async(queue, ^&#123;                sleep(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span>                NSLog(@&quot;dispatch_barrier_sync 之后的任务:%d&quot;,i)<span class="hljs-comment">;</span>            &#125;)<span class="hljs-comment">;</span>        &#125;        else &#123;            dispatch_async(queue, ^&#123;                NSLog(@&quot;dispatch_barrier_sync 之后的任务:%d&quot;,i)<span class="hljs-comment">;</span>            &#125;)<span class="hljs-comment">;</span>        &#125;    &#125;        /**     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:48.135837</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043503</span>] dispatch_barrier_async 所在线程 &lt;NSThread: <span class="hljs-number">0</span>x60<span class="hljs-number">00014820c0</span>&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:48.137458</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043615</span>] dispatch_barrier_sync 之前的任务:<span class="hljs-number">1</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:48.152424</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043615</span>] dispatch_barrier_sync 之前的任务:<span class="hljs-number">3</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:48.152613</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043615</span>] dispatch_barrier_sync 之前的任务:<span class="hljs-number">5</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:48.152732</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043711</span>] dispatch_barrier_sync 之前的任务:<span class="hljs-number">7</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:48.152829</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043615</span>] dispatch_barrier_sync 之前的任务:<span class="hljs-number">9</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:49.140811</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043611</span>] dispatch_barrier_sync 之前的任务:<span class="hljs-number">0</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:49.153305</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043710</span>] dispatch_barrier_sync 之前的任务:<span class="hljs-number">6</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:49.153305</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043609</span>] dispatch_barrier_sync 之前的任务:<span class="hljs-number">2</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:49.153305</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043709</span>] dispatch_barrier_sync 之前的任务:<span class="hljs-number">4</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:49.153359</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043712</span>] dispatch_barrier_sync 之前的任务:<span class="hljs-number">8</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:49.153667</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043712</span>] dispatch_barrier_sync 任务执行 &lt;NSThread: <span class="hljs-number">0</span>x60000140dd00&gt;&#123;number = <span class="hljs-number">7</span>, name = (null)&#125;     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:49.153994</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043712</span>] dispatch_barrier_sync 之后的任务:<span class="hljs-number">1</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:49.154061</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043710</span>] dispatch_barrier_sync 之后的任务:<span class="hljs-number">3</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:49.154194</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043710</span>] dispatch_barrier_sync 之后的任务:<span class="hljs-number">5</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:49.154419</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043714</span>] dispatch_barrier_sync 之后的任务:<span class="hljs-number">7</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:49.154460</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043713</span>] dispatch_barrier_sync 之后的任务:<span class="hljs-number">9</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:50.154831</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043709</span>] dispatch_barrier_sync 之后的任务:<span class="hljs-number">0</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:50.154831</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043611</span>] dispatch_barrier_sync 之后的任务:<span class="hljs-number">4</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:50.154869</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043712</span>] dispatch_barrier_sync 之后的任务:<span class="hljs-number">6</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:50.154869</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043615</span>] dispatch_barrier_sync 之后的任务:<span class="hljs-number">8</span>     <span class="hljs-number">2019-12-19</span> <span class="hljs-number">13</span>:<span class="hljs-number">40:50.154867</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">8655</span>:<span class="hljs-number">6043609</span>] dispatch_barrier_sync 之后的任务:<span class="hljs-number">2</span>          */&#125;</code></pre></li></ul><h5 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h5><p>dispatch_once能保证任务只会被执行一次，同时多线程调用也是线程安全的。</p><p>原理：dispatch_once用原子性操作block执行完成标记位，同时用信号量确保只有一个线程执行block，等block执行完再唤醒所有等待中的线程。</p><p>应用场景：</p><ol><li>dispatch_once 常被用于创建单例</li><li>只需执行一次的函数都可以使用</li></ol><p>demo:</p><p>AFNetworking 库中 </p><pre><code class="hljs awk">/* AFNetworking 库中创建队列 <span class="hljs-number">1</span>、用到时才创建 <span class="hljs-number">2</span>、确保只要创建一次 <span class="hljs-number">3</span>、需要线程安全 综上原因，使用 dispatch_once 是最优选择  */<span class="hljs-regexp">//</span>static dispatch_queue_t url_session_manager_processing_queue() &#123;<span class="hljs-regexp">//</span>    static dispatch_queue_t af_url_session_manager_processing_queue;<span class="hljs-regexp">//</span>    static dispatch_once_t onceToken;<span class="hljs-regexp">//</span>    dispatch_once(&amp;onceToken, ^&#123;<span class="hljs-regexp">//</span>        af_url_session_manager_processing_queue = dispatch_queue_create(<span class="hljs-string">&quot;com.alamofire.networking.session.manager.processing&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<span class="hljs-regexp">//</span>    &#125;);<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>    return af_url_session_manager_processing_queue;<span class="hljs-regexp">//</span>&#125;</code></pre><p>单利</p><pre><code class="hljs dns">- (void)test1 &#123;    TDManager *manager1 = [TDManager shareManager]<span class="hljs-comment">;</span>    TDManager *manager2 = [TDManager new]<span class="hljs-comment">;</span>    TDManager *manager3 = [[TDManager alloc] init]<span class="hljs-comment">;</span>    TDManager *manager4 = [manager1 copy]<span class="hljs-comment">;</span>    TDManager *manager5 = [manager1 mutableCopy]<span class="hljs-comment">;</span>        NSLog(@&quot;manager1:%p&quot;,manager1)<span class="hljs-comment">;</span>    NSLog(@&quot;manager2:%p&quot;,manager2)<span class="hljs-comment">;</span>    NSLog(@&quot;manager3:%p&quot;,manager3)<span class="hljs-comment">;</span>    NSLog(@&quot;manager4:%p&quot;,manager4)<span class="hljs-comment">;</span>    NSLog(@&quot;manager5:%p&quot;,manager5)<span class="hljs-comment">;</span>        /*     打印内存地址都一致，起到了单利效果          <span class="hljs-number">2019-12-20</span> <span class="hljs-number">17</span>:<span class="hljs-number">00</span>:<span class="hljs-number">15.974273</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">30701</span>:<span class="hljs-number">6628246</span>] manager1:<span class="hljs-number">0</span>x60<span class="hljs-number">00021d68b0</span>     <span class="hljs-number">2019-12-20</span> <span class="hljs-number">17</span>:<span class="hljs-number">00</span>:<span class="hljs-number">15.974428</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">30701</span>:<span class="hljs-number">6628246</span>] manager2:<span class="hljs-number">0</span>x60<span class="hljs-number">00021d68b0</span>     <span class="hljs-number">2019-12-20</span> <span class="hljs-number">17</span>:<span class="hljs-number">00</span>:<span class="hljs-number">15.974544</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">30701</span>:<span class="hljs-number">6628246</span>] manager3:<span class="hljs-number">0</span>x60<span class="hljs-number">00021d68b0</span>     <span class="hljs-number">2019-12-20</span> <span class="hljs-number">17</span>:<span class="hljs-number">00</span>:<span class="hljs-number">15.974634</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">30701</span>:<span class="hljs-number">6628246</span>] manager4:<span class="hljs-number">0</span>x60<span class="hljs-number">00021d68b0</span>     <span class="hljs-number">2019-12-20</span> <span class="hljs-number">17</span>:<span class="hljs-number">00</span>:<span class="hljs-number">15.974714</span>+<span class="hljs-number">0800</span> threadDemo[<span class="hljs-number">30701</span>:<span class="hljs-number">6628246</span>] manager5:<span class="hljs-number">0</span>x60<span class="hljs-number">00021d68b0</span>     */&#125;</code></pre><h5 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h5><p>dispatch_apply类似一个for循环，会在指定的dispatch queue中运行block任务n次.<br>    如果队列是并发队列，则会并发执行block任务;<br>    如果队列是串行队列，则会串行在当前队列执行block任务;<br>    dispatch_apply是一个同步调用，block任务执行n次后才返回。</p><p>demo:</p><p>串行队列中执行</p><pre><code class="hljs yaml"><span class="hljs-string">///</span> <span class="hljs-string">串行队列中执行,效率还是略高于普通的</span> <span class="hljs-string">for</span> <span class="hljs-string">循环</span><span class="hljs-bullet">-</span> <span class="hljs-string">(void)test1</span> &#123;    <span class="hljs-string">NSLog(@&quot;start&quot;);</span>          <span class="hljs-string">dispatch_queue_t</span> <span class="hljs-string">queue=</span> <span class="hljs-string">dispatch_queue_create(&quot;asyncSerial&quot;</span>, <span class="hljs-string">DISPATCH_QUEUE_SERIAL);</span><span class="hljs-string">//</span>    <span class="hljs-string">dispatch_queue_t</span> <span class="hljs-string">queue</span> <span class="hljs-string">=</span> <span class="hljs-string">dispatch_queue_create(&quot;asyncConcurrent&quot;</span>, <span class="hljs-string">DISPATCH_QUEUE_CONCURRENT);</span>        <span class="hljs-string">CFTimeInterval</span> <span class="hljs-string">startTimeInterval</span> <span class="hljs-string">=</span> <span class="hljs-string">CACurrentMediaTime();</span>    <span class="hljs-string">//dispatch_apply是一个同步调用，block任务执行都执行完才返回，会卡住当前线程（无论串行还是并发队列）</span>    <span class="hljs-string">dispatch_apply(10000</span>, <span class="hljs-string">queue</span>, <span class="hljs-string">^(size_t</span> <span class="hljs-string">i)</span> &#123;        <span class="hljs-string">//</span>        [<span class="hljs-string">NSThread</span> <span class="hljs-string">sleepForTimeInterval:arc4random()%1</span>]<span class="hljs-string">;</span>                <span class="hljs-string">NSLog(@&quot;%zu</span> <span class="hljs-string">%@&quot;</span>,<span class="hljs-string">i</span>,[<span class="hljs-string">NSThread</span> <span class="hljs-string">currentThread</span>]<span class="hljs-string">);</span>    &#125;<span class="hljs-string">);</span>    <span class="hljs-string">CFTimeInterval</span> <span class="hljs-string">endTimeInterval</span> <span class="hljs-string">=</span> <span class="hljs-string">CACurrentMediaTime();</span>    <span class="hljs-string">NSLog(@&quot;end&quot;);</span>        <span class="hljs-string">NSLog(@&quot;endTimeInterval</span> <span class="hljs-bullet">-</span> <span class="hljs-string">startTimeInterval:%f&quot;</span>,<span class="hljs-string">endTimeInterval</span> <span class="hljs-bullet">-</span> <span class="hljs-string">startTimeInterval);</span>        <span class="hljs-string">/*</span>     <span class="hljs-number">2019-12-19 15:46:19.281002</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9336</span><span class="hljs-string">:6115616</span>] <span class="hljs-number">0</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x6000008aa0c0</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>&#125;     <span class="hljs-number">2019-12-19 15:46:19.281440</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9336</span><span class="hljs-string">:6115616</span>] <span class="hljs-number">1</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x6000008aa0c0</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>&#125;     <span class="hljs-number">2019-12-19 15:46:19.281440</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9336</span><span class="hljs-string">:6115616</span>] <span class="hljs-number">2</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x6000008aa0c0</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>&#125;     <span class="hljs-number">2019-12-19 15:46:19.281440</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9336</span><span class="hljs-string">:6115616</span>] <span class="hljs-number">3</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x6000008aa0c0</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>&#125;     <span class="hljs-string">....</span>     <span class="hljs-number">2019-12-19 15:46:19.281002</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9336</span><span class="hljs-string">:6115616</span>] <span class="hljs-number">9997</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x6000008aa0c0</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>&#125;     <span class="hljs-number">2019-12-19 15:46:19.281440</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9336</span><span class="hljs-string">:6115616</span>] <span class="hljs-number">9998</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x6000008aa0c0</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>&#125;     <span class="hljs-number">2019-12-19 15:46:19.282302</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9336</span><span class="hljs-string">:6115616</span>] <span class="hljs-number">9999</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x6000008aa0c0</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>&#125;     <span class="hljs-number">2019-12-19 15:46:19.282819</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9336</span><span class="hljs-string">:6115616</span>] <span class="hljs-string">end</span>     <span class="hljs-number">2019-12-19 15:46:19.283203</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9336</span><span class="hljs-string">:6115616</span>] <span class="hljs-string">endTimeInterval</span> <span class="hljs-bullet">-</span> <span class="hljs-string">startTimeInterval:4.206515</span>          <span class="hljs-string">*/</span>&#125;</code></pre><p>并发队列执行</p><pre><code class="hljs yaml"><span class="hljs-string">///</span> <span class="hljs-string">并发队列中执行，比串行队列效率高</span><span class="hljs-bullet">-</span> <span class="hljs-string">(void)test2</span> &#123;    <span class="hljs-string">NSLog(@&quot;start&quot;);</span>        <span class="hljs-string">dispatch_queue_t</span> <span class="hljs-string">queue</span> <span class="hljs-string">=</span> <span class="hljs-string">dispatch_queue_create(&quot;asyncConcurrent&quot;</span>, <span class="hljs-string">DISPATCH_QUEUE_CONCURRENT);</span>        <span class="hljs-string">CFTimeInterval</span> <span class="hljs-string">startTimeInterval</span> <span class="hljs-string">=</span> <span class="hljs-string">CACurrentMediaTime();</span>    <span class="hljs-string">//dispatch_apply是一个同步调用，block任务执行都执行完才返回，会卡住当前线程（无论串行还是并发队列）</span>    <span class="hljs-string">dispatch_apply(10000</span>, <span class="hljs-string">queue</span>, <span class="hljs-string">^(size_t</span> <span class="hljs-string">i)</span> &#123;        <span class="hljs-string">//</span>        [<span class="hljs-string">NSThread</span> <span class="hljs-string">sleepForTimeInterval:arc4random()%1</span>]<span class="hljs-string">;</span>                <span class="hljs-string">NSLog(@&quot;%zu</span> <span class="hljs-string">%@&quot;</span>,<span class="hljs-string">i</span>,[<span class="hljs-string">NSThread</span> <span class="hljs-string">currentThread</span>]<span class="hljs-string">);</span>    &#125;<span class="hljs-string">);</span>    <span class="hljs-string">CFTimeInterval</span> <span class="hljs-string">endTimeInterval</span> <span class="hljs-string">=</span> <span class="hljs-string">CACurrentMediaTime();</span>    <span class="hljs-string">NSLog(@&quot;end&quot;);</span>        <span class="hljs-string">NSLog(@&quot;endTimeInterval</span> <span class="hljs-bullet">-</span> <span class="hljs-string">startTimeInterval:%f&quot;</span>,<span class="hljs-string">endTimeInterval</span> <span class="hljs-bullet">-</span> <span class="hljs-string">startTimeInterval);</span>        <span class="hljs-string">/*</span>     <span class="hljs-number">2019-12-19 16:23:13.700098</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9717</span><span class="hljs-string">:6141471</span>] <span class="hljs-number">0</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x600002f5a140</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>&#125;     <span class="hljs-number">2019-12-19 16:23:13.700240</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9717</span><span class="hljs-string">:6141471</span>] <span class="hljs-number">1</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x600002f5a140</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>&#125;     <span class="hljs-number">2019-12-19 16:23:13.700767</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9717</span><span class="hljs-string">:6141471</span>] <span class="hljs-number">2</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x600002f5a140</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>&#125;     <span class="hljs-string">...</span>     <span class="hljs-number">2019-12-19 16:23:17.318679</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9717</span><span class="hljs-string">:6141471</span>] <span class="hljs-number">9995</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x600002f5a140</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>&#125;     <span class="hljs-number">2019-12-19 16:23:17.318908</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9717</span><span class="hljs-string">:6141715</span>] <span class="hljs-number">9996</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x600002fd6900</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">8</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">(null)</span>&#125;     <span class="hljs-number">2019-12-19 16:23:17.319090</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9717</span><span class="hljs-string">:6141471</span>] <span class="hljs-number">9997</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x600002f5a140</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>&#125;     <span class="hljs-number">2019-12-19 16:23:17.319294</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9717</span><span class="hljs-string">:6141714</span>] <span class="hljs-number">9998</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x600002fd6780</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">7</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">(null)</span>&#125;     <span class="hljs-number">2019-12-19 16:23:17.319498</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9717</span><span class="hljs-string">:6141662</span>] <span class="hljs-number">9999</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x600002fd6740</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">6</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">(null)</span>&#125;     <span class="hljs-number">2019-12-19 16:23:17.321036</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9717</span><span class="hljs-string">:6141471</span>] <span class="hljs-string">end</span>     <span class="hljs-number">2019-12-19 16:23:17.321507</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">9717</span><span class="hljs-string">:6141471</span>] <span class="hljs-string">endTimeInterval</span> <span class="hljs-bullet">-</span> <span class="hljs-string">startTimeInterval:3.620898</span>     <span class="hljs-string">*/</span>&#125;</code></pre><h5 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h5><p>延时函数，不会卡住所在线程</p><p>demo:</p><p>任务执行所在队列为主队列，任务在主线程中执行的</p><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">(void)test1</span> &#123;    <span class="hljs-string">NSLog(@&quot;1</span> <span class="hljs-string">%@&quot;</span>,[<span class="hljs-string">NSThread</span> <span class="hljs-string">currentThread</span>]<span class="hljs-string">);</span>    <span class="hljs-string">dispatch_after(dispatch_time(DISPATCH_TIME_NOW</span>, <span class="hljs-string">(int64_t)(2</span> <span class="hljs-string">*</span> <span class="hljs-string">NSEC_PER_SEC))</span>, <span class="hljs-string">dispatch_get_main_queue()</span>, <span class="hljs-string">^</span>&#123;        <span class="hljs-string">NSLog(@&quot;2</span> <span class="hljs-string">%@&quot;</span>,[<span class="hljs-string">NSThread</span> <span class="hljs-string">currentThread</span>]<span class="hljs-string">);</span>    &#125;<span class="hljs-string">);</span>    <span class="hljs-string">NSLog(@&quot;3</span> <span class="hljs-string">%@&quot;</span>,[<span class="hljs-string">NSThread</span> <span class="hljs-string">currentThread</span>]<span class="hljs-string">);</span>        <span class="hljs-string">/*</span>     <span class="hljs-number">2019-12-19 14:58:46.529442</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">8900</span><span class="hljs-string">:6083577</span>] <span class="hljs-number">1</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x6000036b8b80</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>&#125;     <span class="hljs-number">2019-12-19 14:58:46.529659</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">8900</span><span class="hljs-string">:6083577</span>] <span class="hljs-number">3</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x6000036b8b80</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>&#125;     <span class="hljs-number">2019-12-19 14:58:48.529967</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">8900</span><span class="hljs-string">:6083577</span>] <span class="hljs-number">2</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x6000036b8b80</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>&#125;     <span class="hljs-string">*/</span>&#125;</code></pre><p>修改任务执行所在队列为并发队列. 任务是在子线程中执行的.</p><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">(void)test2</span> &#123;    <span class="hljs-string">NSLog(@&quot;1</span> <span class="hljs-string">%@&quot;</span>,[<span class="hljs-string">NSThread</span> <span class="hljs-string">currentThread</span>]<span class="hljs-string">);</span>    <span class="hljs-string">dispatch_after(dispatch_time(DISPATCH_TIME_NOW</span>, <span class="hljs-string">(int64_t)(2</span> <span class="hljs-string">*</span> <span class="hljs-string">NSEC_PER_SEC))</span>, <span class="hljs-string">dispatch_get_global_queue(0</span>, <span class="hljs-number">0</span><span class="hljs-string">)</span>, <span class="hljs-string">^</span>&#123;        <span class="hljs-string">NSLog(@&quot;2</span> <span class="hljs-string">%@&quot;</span>,[<span class="hljs-string">NSThread</span> <span class="hljs-string">currentThread</span>]<span class="hljs-string">);</span>    &#125;<span class="hljs-string">);</span>    <span class="hljs-string">NSLog(@&quot;3</span> <span class="hljs-string">%@&quot;</span>,[<span class="hljs-string">NSThread</span> <span class="hljs-string">currentThread</span>]<span class="hljs-string">);</span>        <span class="hljs-string">/*</span>     <span class="hljs-number">2019-12-19 15:00:48.693679</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">8943</span><span class="hljs-string">:6085531</span>] <span class="hljs-number">1</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x600000d72ac0</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>&#125;     <span class="hljs-number">2019-12-19 15:00:48.694252</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">8943</span><span class="hljs-string">:6085531</span>] <span class="hljs-number">3</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x600000d72ac0</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>&#125;     <span class="hljs-number">2019-12-19 15:00:50.855673</span><span class="hljs-string">+0800</span> <span class="hljs-string">threadDemo</span>[<span class="hljs-number">8943</span><span class="hljs-string">:6085641</span>] <span class="hljs-number">2</span> <span class="hljs-string">&lt;NSThread:</span> <span class="hljs-number">0x600000d21080</span><span class="hljs-string">&gt;</span>&#123;<span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-number">3</span>, <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">(null)</span>&#125;     <span class="hljs-string">*/</span>&#125;</code></pre><p>修改任务执行所在队列为自定义的串行队列. 任务是在子线程中执行的.<br>通过查看打印结果，很明显延时函数底层肯定是异步执行任务。只有在主队列时任务才在主线程执行</p><pre><code class="hljs reasonml">- (void)test3 &#123;    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;1 %@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;    dispatch_queue_t queue = dispatch<span class="hljs-constructor">_queue_create(<span class="hljs-string">&quot;syncConcrrent&quot;</span>, DISPATCH_QUEUE_CONCURRENT)</span>;    dispatch<span class="hljs-constructor">_after(<span class="hljs-params">dispatch_time</span>(DISPATCH_TIME_NOW, (<span class="hljs-params">int64_t</span>)</span>(<span class="hljs-number">2</span><span class="hljs-operator"> * </span>NSEC_PER_SEC)), queue, ^&#123;        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;2 %@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;    &#125;);    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;3 %@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;        <span class="hljs-comment">/*</span><span class="hljs-comment">     2019-12-19 15:09:06.207532+0800 threadDemo[9037:6090879] 1 &lt;NSThread: 0x600001960f40&gt;&#123;number = 1, name = main&#125;</span><span class="hljs-comment">     2019-12-19 15:09:06.207745+0800 threadDemo[9037:6090879] 3 &lt;NSThread: 0x600001960f40&gt;&#123;number = 1, name = main&#125;</span><span class="hljs-comment">     2019-12-19 15:09:08.207879+0800 threadDemo[9037:6090962] 2 &lt;NSThread: 0x6000019ee4c0&gt;&#123;number = 8, name = (null)&#125;</span><span class="hljs-comment">     */</span>&#125;</code></pre><h5 id="Dispatch-Source"><a href="#Dispatch-Source" class="headerlink" title="Dispatch Source"></a>Dispatch Source</h5><p>Dispatch Source是BSD系统内核惯有功能kqueue的包装，kqueue是在XNU内核中发生各种事件时，在应用程序编程方执行处理的技术。<br> 它的CPU负荷非常小，尽量不占用资源。当事件发生时，Dispatch Source会在指定的Dispatch Queue中执行事件的处理。</p><p> dispatch_source_t<br> 一共有一下几种类型（dispatch_source_type_t):</p><p> 监控进程：DISPATCH_SOURCE_TYPE_PROC,<br> 定时器：DISPATCH_SOURCE_TYPE_TIMER,<br> 从描述符中读取数据：DISPATCH_SOURCE_TYPE_READ,<br> 向描述符中写入字符：DISPATCH_SOURCE_TYPE_WRITE,<br> 监控文件系统对象:DISPATCH_SOURCE_TYPE_VNODE,…..</p><p> demo演示定时器使用</p><p> Dispatch Source使用最多的就是用来实现定时器，source创建后默认是暂停状态，需要手动调用dispatch_resume启动定时器。dispatch_after只是封装调用了dispatch source定时器，然后在回调函数中执行定义的block。</p><p> Dispatch Source定时器使用时也有一些需要注意的地方，不然很可能会引起crash：</p><p> 1、循环引用：因为dispatch_source_set_event_handler回调是个block，在添加到source的链表上时会执行copy并被source强引用，如果block里持有了self，self又持有了source的话，就会引起循环引用。正确的方法是使用weak+strong或者提前调用dispatch_source_cancel取消timer。</p><p> 2、dispatch_resume和dispatch_suspend调用次数需要平衡，如果重复调用dispatch_resume则会崩溃,因为重复调用会让dispatch_resume代码里if分支不成立，从而执行了DISPATCH_CLIENT_CRASH(“Over-resume of an object”)导致崩溃。</p><p> 3、source在suspend状态下，如果直接设置source = nil或者重新创建source都会造成crash。正确的方式是在resume状态下调用dispatch_source_cancel(source)后再重新创建。</p><h6 id="GCD定时器"><a href="#GCD定时器" class="headerlink" title="GCD定时器"></a>GCD定时器</h6><p>定时器不受runloop影响，效率高。</p><p>demo:</p><pre><code class="hljs angelscript">- (<span class="hljs-built_in">void</span>)test1 &#123;    __block <span class="hljs-built_in">int</span> timeout=<span class="hljs-number">30</span>; <span class="hljs-comment">//倒计时时间</span>    dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, dispatch_get_main_queue());    dispatch_source_set_timer(_timer, dispatch_time(DISPATCH_TIME_NOW, <span class="hljs-number">0</span>), <span class="hljs-number">1</span> * NSEC_PER_SEC, <span class="hljs-number">0</span>);    dispatch_source_set_event_handler(_timer, ^&#123;        <span class="hljs-keyword">if</span>(timeout&lt;=<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//倒计时结束，关闭</span>            dispatch_source_cancel(_timer);            dispatch_async(dispatch_get_main_queue(), ^&#123;                <span class="hljs-comment">//设置界面的按钮显示 根据自己需求设置</span>                NSLog(@<span class="hljs-string">&quot;time 倒计时结束&quot;</span>);            &#125;);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">int</span> minutes = timeout / <span class="hljs-number">60</span>;            <span class="hljs-built_in">int</span> seconds = timeout % <span class="hljs-number">60</span>;            NSString *strTime = [NSString <span class="hljs-built_in">string</span>WithFormat:@<span class="hljs-string">&quot;%d分%.2d秒后重新获取验证码&quot;</span>,minutes, seconds];            dispatch_async(dispatch_get_main_queue(), ^&#123;                <span class="hljs-comment">//设置界面的按钮显示 根据自己需求设置</span>                NSLog(@<span class="hljs-string">&quot;strTime %@&quot;</span>,strTime);            &#125;);            timeout--;        &#125;    &#125;);    <span class="hljs-comment">//启动timer</span>    dispatch_resume(_timer);&#125;</code></pre><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>只有当多个线程同时去访问并且修改一块资源的内容时可能会有线程安全问题。</p><p>当多线程只是访问并不做修改，不会出现线程安全问题。</p><p>举例：</p><p>假设银行卡有余额1000元，有2个线程A、B；<br>现在A、B同时查询余额，得到的都是1000元；<br>然后A线程存入1000元，余额为1000 + 1000 = 2000；<br>然后B线程取出500元，余额为1000 - 500 = 500；<br>这样就出现线程安全问题了，下次去查询余额就只有500了😹</p><p>为了保证线程安全，需要给线程加锁。</p><h5 id="同步方案"><a href="#同步方案" class="headerlink" title="同步方案"></a>同步方案</h5><h6 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h6><p>OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源</p><p>目前已经不再安全，可能会出现优先级反转问题</p><p>如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁</p><p>需要导入头文件#import &lt;libkern/OSAtomic.h&gt;</p><h6 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h6><p>os_unfair_lock用于取代不安全的OSSpinLock ，从iOS10开始才支持</p><p>从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等</p><p>需要导入头文件#import &lt;os/lock.h&gt;</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2361" alt="6a32356cd62bffb395c55eff0729375d.png"> </p><h6 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h6><p>mutex叫做”互斥锁”，等待锁的线程会处于休眠状态</p><p>需要导入头文件#import &lt;pthread.h&gt;</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2362" alt="9848ab391ea130b47de60ac90949c5d7.png"><br><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2363" alt="1e9bf9133cafc7fe1e68e53239f70754.png"><br><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2364" alt="8d423ed41c44ae90fe1f4e55b26964f9.png"><br><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2365" alt="eeeb5c6a5d872001eb1f1c7917d810e0.png"></p><h6 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h6><p>semaphore叫做”信号量”</p><p>信号量的初始值，可以用来控制线程并发访问的最大数量</p><p>信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2366" alt="844e0aa7a21c56f9568325ebf1df04b2.png"></p><h6 id="dispatch-queue-DISPATCH-QUEUE-SERIAL"><a href="#dispatch-queue-DISPATCH-QUEUE-SERIAL" class="headerlink" title="dispatch_queue(DISPATCH_QUEUE_SERIAL)"></a>dispatch_queue(DISPATCH_QUEUE_SERIAL)</h6><p>直接使用GCD的串行队列，也是可以实现线程同步的</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2367" alt="4da7c092e947d453289322166866701b.png"></p><h6 id="NSLock、NSRecursiveLock"><a href="#NSLock、NSRecursiveLock" class="headerlink" title="NSLock、NSRecursiveLock"></a>NSLock、NSRecursiveLock</h6><p>NSLock是对mutex普通锁的封装</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2371" alt="1cb32ab8ac4967086fbbee75dbb15433.png"><br><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2372" alt="f288c06d4f718baddb110b329023936d.png"><br><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2373" alt="c02fbd60aa09ed858fec23c3b8d4a6a3.png"></p><p>NSRecursiveLock也是对mutex递归锁的封装，API跟NSLock基本一致</p><h6 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h6><p>NSCondition是对mutex和cond的封装</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2370" alt="5f93ec4282fecd19e347dd383be722ec.png"></p><h6 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h6><p>NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2369" alt="65483fd9373eed4ce11ef7ecb2b60fda.png"></p><h6 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h6><p>@synchronized是对mutex递归锁的封装</p><p>源码查看：objc4中的objc-sync.mm文件</p><p>@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2368" alt="27d559c23065755f60c6afe842dd3096.png"></p><h5 id="同步方案性能比较"><a href="#同步方案性能比较" class="headerlink" title="同步方案性能比较"></a>同步方案性能比较</h5><p>性能从高到低排序<br>os_unfair_lock<br>OSSpinLock<br>dispatch_semaphore<br>pthread_mutex<br>dispatch_queue(DISPATCH_QUEUE_SERIAL)<br>NSLock<br>NSCondition<br>pthread_mutex(recursive)<br>NSRecursiveLock<br>NSConditionLock<br>@synchronized</p><h5 id="自旋-互斥锁"><a href="#自旋-互斥锁" class="headerlink" title="自旋 / 互斥锁"></a>自旋 / 互斥锁</h5><h6 id="什么是自旋锁"><a href="#什么是自旋锁" class="headerlink" title="什么是自旋锁"></a>什么是自旋锁</h6><p>等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源</p><h6 id="什么是互斥锁"><a href="#什么是互斥锁" class="headerlink" title="什么是互斥锁"></a>什么是互斥锁</h6><p>等待锁的线程会处于休眠状态</p><h6 id="什么情况使用自旋锁更划算？"><a href="#什么情况使用自旋锁更划算？" class="headerlink" title="什么情况使用自旋锁更划算？"></a>什么情况使用自旋锁更划算？</h6><p>预计线程等待锁的时间很短<br>加锁的代码（临界区）经常被调用，但竞争情况很少发生<br>CPU资源不紧张<br>多核处理器</p><h6 id="什么情况使用互斥锁更划算？"><a href="#什么情况使用互斥锁更划算？" class="headerlink" title="什么情况使用互斥锁更划算？"></a>什么情况使用互斥锁更划算？</h6><p>预计线程等待锁的时间较长<br>单核处理器<br>临界区有IO操作<br>临界区代码复杂或者循环量大<br>临界区竞争非常激烈 </p><h5 id="高性能读写安全方案"><a href="#高性能读写安全方案" class="headerlink" title="高性能读写安全方案"></a>高性能读写安全方案</h5><h6 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h6><p>同一时间，只能有1个线程进行写的操作<br>同一时间，允许有多个线程进行读的操作<br>同一时间，不允许既有写的操作，又有读的操作</p><h6 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h6><p>“多读单写”，经常用于文件等数据的读写操作，实现方案有<br>pthread_rwlock：读写锁<br>dispatch_barrier_async：异步栅栏调用</p><p>demo:</p><p>由于 NSMutableDictionary 线程是不安全的。</p><p>现在实现一个线程安全的可变字典</p><pre><code class="hljs objectivec"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> (^ThreadSafeBlock)(ThreadSafeMutableDictionary *dict, <span class="hljs-built_in">NSString</span> *key, <span class="hljs-keyword">id</span> object);<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ThreadSafeMutableDictionary</span> </span>&#123;    <span class="hljs-built_in">dispatch_queue_t</span> _concurrentQueue;&#125;- (<span class="hljs-keyword">instancetype</span>)init &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) &#123;        _concurrentQueue = dispatch_queue_create(<span class="hljs-string">@&quot;com.thread.ThreadSafeMutableDictionary&quot;</span>, DISPATCH_QUEUE_CONCURRENT);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;&#125;- (<span class="hljs-keyword">void</span>)objectForKey:(<span class="hljs-built_in">NSString</span> *)key block:(ThreadSafeBlock)block &#123;    <span class="hljs-keyword">id</span> cKey = [key <span class="hljs-keyword">copy</span>];    __<span class="hljs-keyword">weak</span> __typeof__(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;    <span class="hljs-built_in">dispatch_sync</span>(_concurrentQueue, ^&#123;        ThreadSafeMutableDictionary *strongSelf = weakSelf;        <span class="hljs-keyword">if</span> (!strongSelf) &#123;            block(<span class="hljs-literal">nil</span>,cKey,<span class="hljs-literal">nil</span>);            <span class="hljs-keyword">return</span> ;        &#125;                <span class="hljs-keyword">id</span> object = [strongSelf objectForKey:cKey];        block(strongSelf,cKey,object);    &#125;);&#125;- (<span class="hljs-keyword">void</span>)setObject:(<span class="hljs-keyword">id</span>)object forKey:(<span class="hljs-built_in">NSString</span> *)key block:(ThreadSafeBlock)block &#123;    <span class="hljs-keyword">if</span> (!key || !object) &#123;        <span class="hljs-keyword">return</span>;    &#125;        <span class="hljs-built_in">NSString</span> *aKey = [key <span class="hljs-keyword">copy</span>];    __<span class="hljs-keyword">weak</span> __typeof__(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;    dispatch_barrier_async(_concurrentQueue, ^&#123;        ThreadSafeMutableDictionary *strongSelf = weakSelf;        <span class="hljs-keyword">if</span> (!strongSelf) &#123;            block(<span class="hljs-literal">nil</span>,aKey,<span class="hljs-literal">nil</span>);            <span class="hljs-keyword">return</span> ;        &#125;                [<span class="hljs-keyword">self</span> setObject:object forKey:aKey];        <span class="hljs-keyword">if</span> (block) &#123;            block(strongSelf,aKey,object);        &#125;    &#125;);&#125;</code></pre><h3 id="多线程优化"><a href="#多线程优化" class="headerlink" title="多线程优化"></a>多线程优化</h3><h5 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h5><h6 id="尽量减少队列切换"><a href="#尽量减少队列切换" class="headerlink" title="尽量减少队列切换"></a>尽量减少队列切换</h6><p>当线程数量超过 CPU 核心数量，CPU 核心通过线程调度切换用户态线程，意味着有上下文的转换，过多的上下文切换会带来资源开销。 </p><p>如下代码：</p><pre><code class="hljs objectivec"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;x.x.x&quot;</span>, DISPATCH_QUEUE_CONCURRENT);- (<span class="hljs-keyword">void</span>)tast1 &#123;    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;        <span class="hljs-comment">//执行任务1</span>        <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;            <span class="hljs-comment">//任务1完成</span>            [<span class="hljs-keyword">self</span> tast2];        &#125;);    &#125;);&#125;- (<span class="hljs-keyword">void</span>)tast2 &#123;    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;        <span class="hljs-comment">//执行任务2</span>        <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;            <span class="hljs-comment">//任务2完成</span>        &#125;);    &#125;);&#125;</code></pre><p>这里创建了一个并行队列，调用 tast1 会执行两个任务，任务2要等待任务1执行完成，这里一共有四次队列的切换。其实是没必要的。</p><p>优化后：</p><pre><code class="hljs cpp"><span class="hljs-keyword">dispatch_queue_t</span> <span class="hljs-built_in">queue</span> = dispatch_queue_create(<span class="hljs-string">&quot;x.x.x&quot;</span>, DISPATCH_QUEUE_SERIAL);dispatch_async(<span class="hljs-built_in">queue</span>, ^&#123;    <span class="hljs-comment">//执行任务1</span>    <span class="hljs-comment">//执行任务2</span>    dispatch_async(dispatch_get_main_queue(), ^&#123;        <span class="hljs-comment">//任务1、2完成</span>    &#125;);&#125;);</code></pre><h6 id="控制线程数量"><a href="#控制线程数量" class="headerlink" title="控制线程数量"></a>控制线程数量</h6><p>使用 GCD 并行队列，当任务过多且耗时较长时，队列会开辟大量的线程，而部分线程里面的耗时任务已经耗尽了 CPU 资源，所以其他的线程也只能等待 CPU 时间片，过多的线程也会让线程调度过于频繁。</p><p>GCD 中并行队列并不能限制线程数量，可以创建多个串行队列来模拟并行的效果，业界知名框架 YYKit 就做了这个逻辑，通过和 CPU 核心数量相同的串行队列轮询返回来达到并行队列的效果</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">dispatch_queue_t</span> <span class="hljs-title">YYAsyncLayerGetDisplayQueue</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//最大队列数量</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_QUEUE_COUNT 16</span><span class="hljs-comment">//队列数量</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> queueCount;<span class="hljs-comment">//使用栈区的数组存储队列</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">dispatch_queue_t</span> queues[MAX_QUEUE_COUNT];    <span class="hljs-keyword">static</span> <span class="hljs-keyword">dispatch_once_t</span> onceToken;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int32_t</span> counter = <span class="hljs-number">0</span>;    dispatch_once(&amp;onceToken, ^&#123;<span class="hljs-comment">//串行队列数量和处理器数量相同</span>        queueCount = (<span class="hljs-keyword">int</span>)[NSProcessInfo processInfo].activeProcessorCount;        queueCount = queueCount &lt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;<span class="hljs-comment">//创建串行队列，设置优先级</span>        <span class="hljs-keyword">if</span> ([UIDevice currentDevice].systemVersion.floatValue &gt;= <span class="hljs-number">8.0</span>) &#123;            <span class="hljs-keyword">for</span> (NSUInteger i = <span class="hljs-number">0</span>; i &lt; queueCount; i++) &#123;                <span class="hljs-keyword">dispatch_queue_attr_t</span> attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, <span class="hljs-number">0</span>);                queues[i] = dispatch_queue_create(<span class="hljs-string">&quot;com.ibireme.yykit.render&quot;</span>, attr);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">for</span> (NSUInteger i = <span class="hljs-number">0</span>; i &lt; queueCount; i++) &#123;                queues[i] = dispatch_queue_create(<span class="hljs-string">&quot;com.ibireme.yykit.render&quot;</span>, DISPATCH_QUEUE_SERIAL);                dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>));            &#125;        &#125;    &#125;);<span class="hljs-comment">//轮询返回队列</span>    <span class="hljs-keyword">uint32_t</span> cur = (<span class="hljs-keyword">uint32_t</span>)OSAtomicIncrement32(&amp;counter);    <span class="hljs-keyword">return</span> queues[cur % queueCount];<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> MAX_QUEUE_COUNT</span>&#125;</code></pre><h6 id="线程优先级权衡"><a href="#线程优先级权衡" class="headerlink" title="线程优先级权衡"></a>线程优先级权衡</h6><p>线程调度除了轮转法以外，还有优先级调度的方案，在线程调度时，高优先级的线程会更早的执行。有两个概念需要明确：<br>    a. IO 密集型线程：频繁等待的线程，等待的时候会让出时间片。<br>    b. CPU 密集型线程：很少等待的线程，意味着长时间占用着 CPU。 </p><p>这样就会存在一个问题：<br>    当CPU密集型线程优先级较高，而且长期霸占CPU大部分资源，这样IO密集型线程由于优先级较低，就持续的等待，产生线程饿死的现象。这时系统会根据情况提高IO密集型线程的优先级，但即使这样，等待也是需要时间的。</p><p>这样可以考虑优化的方向：<br>    a. 让 IO 密集型线程优先级高于 CPU 密集型线程。<br>    b. 让紧急的任务拥有更高的优先级。</p><h6 id="主线程任务的优化"><a href="#主线程任务的优化" class="headerlink" title="主线程任务的优化"></a>主线程任务的优化</h6><p>这摘抄了yykit作者的提出的部分内容<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a></p><p>一些耗时的操作尽量移动到子线程执行。</p><p>但是有些操作必须在主线程，比如 UI 类组件的初始化及其布局。 </p><p>那么主线程的优化有哪些方案可以参考呢？</p><p>1、尽量使用轻量级对象</p><p>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。</p><p>2、尽量减少对象的调整</p><p>当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p><p>3、对象销毁其实是可以在后台线程执行的</p><p>这时yykit作者提倡的方式：</p><p>需要注意的是下面的例子中，如果self.array在别的地方还有依赖，那tmp不是唯一的销毁helper。这一套就没用了。</p><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *tmp = <span class="hljs-keyword">self</span>.array;<span class="hljs-keyword">self</span>.array = <span class="hljs-literal">nil</span>;<span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;    [tmp <span class="hljs-keyword">class</span>];&#125;);</code></pre><p>4、内存复用</p><p>最常见的就是cell复用，避免了大量cell对象的创建，节省内存的同时也节省了开辟内存所消耗的时间。</p><p>5、懒加载任务</p><p>懒加载对象，用到时再创建，可以减少没必要的内存开销。开辟内存是要时间的。勉强算是变相的吧任务进行了拆分，不必初始化时就创建一系列对象。</p><p>6、任务拆分排队执行</p><p>将大量的任务拆分开来，监听Runloop运行状态，当runloop将要休息的时候，让 Runloop 循环周期执行少量任务。</p><p>。。。</p><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p><a href="https://github.com/apple/swift-corelibs-libdispatch">GCD源码</a></p><p><a href="http://www.gnustep.org/resources/downloads.php">GNUstep</a></p><p><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/">不再安全的 OSSpinLock</a></p><p><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a></p><p><a href="https://www.jianshu.com/p/594d15d6c6a7">iOS 如何高效的使用多线程</a></p><p><a href="https://xiaozhuanlan.com/u/3785694919">深入浅出 GCD</a></p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><a href="https://github.com/Baichenghui/Study/tree/master/threadDemo">threadDemo</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>YBTaskScheduler 研究</title>
    <link href="/2019/10/20/YBTaskScheduler-%E7%A0%94%E7%A9%B6/"/>
    <url>/2019/10/20/YBTaskScheduler-%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<p>学习<br><a href="https://github.com/indulgeIn/YBTaskScheduler">YBTaskScheduler</a></p><p><a href="https://www.jianshu.com/p/f2a610c77d26">iOS 任务调度器：为 CPU 和内存减负</a></p><p>[TOC]</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><h5 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h5><p>当主线程执行大量的任务会造成卡顿，应该把这些任务移动到子线程异步执行。</p><p>但是异步执行的任务量过大，会导致cpu和内存占用率过高，然后引发一系列其他问题。</p><h5 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h5><h6 id="延时降频"><a href="#延时降频" class="headerlink" title="延时降频"></a>延时降频</h6><p>降低任务执行频率，或延缓任务执行时机，以时间换空间。</p><h6 id="淘汰"><a href="#淘汰" class="headerlink" title="淘汰"></a>淘汰</h6><p>淘汰不必要执行的任务，如已经滑出屏幕的ui异步绘制任务就可以移除，只保留需要显示屏幕可见部分的绘制任务。</p><h6 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h6><p>个人理解这个对降低cpu、内存占用率高没什么作用，允许设置优先级应该是一个附加功能，真正起到作用的是使用runloop起到降频（任务到runloop空闲时才执行）的作用。</p><h3 id="原理和实现"><a href="#原理和实现" class="headerlink" title="原理和实现"></a>原理和实现</h3><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><code>YBTaskScheduler</code> 监听runloop的状态，只有在runloop将要进入空闲状态时才执行任务。</p><p>设置任务最大数量，在添加任务的时候将超过最大限制的任务淘汰。</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><h6 id="命令模式-runloop"><a href="#命令模式-runloop" class="headerlink" title="命令模式 + runloop"></a>命令模式 + runloop</h6><p>想要管理这些复杂的任务，并且在合适的时机调用它们，自然而然的就想到了命令模式。意味着任务不能直接执行，而是把任务作为一个命令装入容器。</p><p>在 Objective-C 中，显然 Block 代码块能解决延迟执行这个问题：</p><pre><code class="hljs clojure">[_scheduler addTask:<span class="hljs-comment">^&#123;</span><span class="hljs-comment">     /* </span><span class="hljs-comment">     具体任务代码</span><span class="hljs-comment">     解压图片、裁剪图片、访问磁盘等 </span><span class="hljs-comment">     */</span><span class="hljs-comment">&#125;</span>]<span class="hljs-comment">;</span></code></pre><p>然后组件将这些代码块“装起来”，组件由此“掌握”了所有的任务，可以自由的决定何时调用这些代码块，何时对某些代码块进行淘汰，还可以实现优先级调度。 </p><p>既然是命令模式，还差一个 Invoker (调用程序)，即何时去触发这些任务。结合 iOS 的技术特点，可以监听 RunLoop 循环周期来实现：</p><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> addRunLoopObserver() &#123;    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;        taskSchedulers = [<span class="hljs-built_in">NSHashTable</span> weakObjectsHashTable];        <span class="hljs-built_in">CFRunLoopObserverRef</span> observer = <span class="hljs-built_in">CFRunLoopObserverCreate</span>(<span class="hljs-built_in">CFAllocatorGetDefault</span>(), kCFRunLoopBeforeWaiting | kCFRunLoopExit, <span class="hljs-literal">true</span>, <span class="hljs-number">0xFFFFFF</span>, runLoopObserverCallBack, <span class="hljs-literal">NULL</span>);        <span class="hljs-built_in">CFRunLoopAddObserver</span>(<span class="hljs-built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);        <span class="hljs-built_in">CFRelease</span>(observer);    &#125;);&#125;</code></pre><p>然后在回调函数中进行任务的调度。</p><h6 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h6><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2355" alt="d4d2cc7e6fc6db790b737872f1549666.png"></p><p>具体策略：</p><p>栈：后加入的任务先执行（可以理解为后加入的任务优先级高），优先淘汰先加入的任务。</p><p>队列：先加入的任务先执行（可以理解为先加入的任务优先级高），优先淘汰后加入的任务。</p><p>优先队列：自定义任务优先级，不支持任务淘汰。</p><h6 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h6><p>为了实现淘汰策略和优先级调度，作者直接使用了 C++ 的数据结构：deque 和priority_queue。</p><p>要实现任务淘汰，所以使用 deque 双端队列来模拟栈和队列，而不是直接使用 stack 和 queue。</p><p>使用 priority_queue 优先队列来处理自定义的优先级调度，它的缺点是不能删除低优先级节点，为了节约时间成本姑且够用。</p><h6 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h6><p>任务的调度可能在任意线程，所以必须要做好容器（栈、队列、优先队列）访问的线程安全问题，组件是使用 pthread_mutex_t 和 dispatch_once 来保证线程安全，同时笔者尽量减少临界区来提高性能。</p><p>值得注意的是，如果不会存在线程安全的代码就不要去加锁了。</p><h3 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h3><h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h5><p>使用策略模式区分不同淘汰策略，以及任务优先级设置。</p><p>使用命令模式，将任务添加和任务调度隔离。可以自由的决定何时调用这些代码块，何时对某些代码块进行淘汰，还可以实现优先级调度。</p><h5 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h5><p>监听runloop回调状态</p><p>将任务放在runloop空闲状态才下执行，避免任务集中执行，起到延缓作用。</p><h5 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h5><p>使用了 C++ 的数据结构：deque 和priority_queue。</p><p>使用 deque 双端队列来模拟栈和队列。</p><p>使用 priority_queue 优先队列来处理自定义的优先级调度。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>YYAsyncLayer 研究</title>
    <link href="/2019/10/20/YYAsyncLayer-%E7%A0%94%E7%A9%B6/"/>
    <url>/2019/10/20/YYAsyncLayer-%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>异步绘制是界面流畅度提升的思路，YYAsyncLayer 是 ibireme 写的一个异步绘制的轮子。质量比较高，涉及到很多优化思维，值得学习。多学技术，学好技术。</p><h3 id="为什么要异步绘制"><a href="#为什么要异步绘制" class="headerlink" title="为什么要异步绘制"></a>为什么要异步绘制</h3><h5 id="屏幕显示图像的原理"><a href="#屏幕显示图像的原理" class="headerlink" title="屏幕显示图像的原理"></a>屏幕显示图像的原理</h5><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2376" alt="9d500c2270433ab8e444083d5cf650f2.png"></p><p>CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2375" alt="eb92699d5650217ec7357a49d5789ca2.png"></p><p>过去的CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。</p><h5 id="双缓冲机制"><a href="#双缓冲机制" class="headerlink" title="双缓冲机制"></a>双缓冲机制</h5><p>显示系统通常会引入两个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。</p><p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象。</p><p>为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p><h5 id="界面卡顿的实质"><a href="#界面卡顿的实质" class="headerlink" title="界面卡顿的实质"></a>界面卡顿的实质</h5><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2374" alt="5f16df9fe174ef3a6879c2bb1f066d27.png"> </p><p>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p><h5 id="UIKit-性能瓶颈"><a href="#UIKit-性能瓶颈" class="headerlink" title="UIKit 性能瓶颈"></a>UIKit 性能瓶颈</h5><p>大部分 UIKit 组件的绘制是在主线程进行，需要 CPU 来进行绘制，当同一时刻过多组件需要绘制或者组件元素过于复杂时，必然会给 CPU 带来压力，这个时候就很容易掉帧（主要是文本控件，大量文本内容的计算和绘制过程都相当繁琐）。</p><h5 id="UIKit-替代方案：CoreAnimation-或-CoreGraphics"><a href="#UIKit-替代方案：CoreAnimation-或-CoreGraphics" class="headerlink" title="UIKit 替代方案：CoreAnimation 或 CoreGraphics"></a>UIKit 替代方案：CoreAnimation 或 CoreGraphics</h5><h6 id="CoreAnimation"><a href="#CoreAnimation" class="headerlink" title="CoreAnimation"></a>CoreAnimation</h6><p>首选优化方案是 CoreAnimation 框架。CALayer 的大部分属性都是由 GPU 绘制的 (硬件层面)，不需要 CPU (软件层面) 做任何绘制。CA 框架下的 CAShapeLayer (多边形绘制)、CATextLayer(文本绘制)、CAGradientLayer (渐变绘制) 等都有较高的效率，非常实用。</p><h6 id="CoreGraphics"><a href="#CoreGraphics" class="headerlink" title="CoreGraphics"></a>CoreGraphics</h6><p>其次在适当的地方可以考虑 CoreGraphics 框架。CoreGraphics 依托于 CPU 的软件绘制。在实现 CALayerDelegate 协议的 -drawLayer:inContext: 方法时（等同于UIView 二次封装的 -drawRect:方法），需要分配一个内存占用较高的上下文 context，与此同时，CALayer 或者其子类需要创建一个等大的寄宿图 contents。当基于 CPU 的软件绘制完成，还需要通过 IPC (进程间通信) 传递给设备显示系统。值得注意的是：当重绘时需要抹除这个上下文重新分配内存。</p><p>不管是创建上下文、重绘带来的内存重新分配、IPC 都会带来性能上的较大开销。所以 CoreGraphics 的性能比较差，日常开发中要尽量避免直接在主线程使用。通常情况下，直接给 CALayer 的 contents 赋值 CGImage 图片或者使用 CALayer 的衍生类就能实现大部分需求，还能充分利用硬件支持，图像处理交给 GPU 当然更加放心。</p><h5 id="多核设备带来的可能性"><a href="#多核设备带来的可能性" class="headerlink" title="多核设备带来的可能性"></a>多核设备带来的可能性</h5><p>通过以上说明，可以了解 CoreGraphics 较为糟糕的性能。然而可喜的是，市面上的设备都已经不是单核了，这就意味着可以通过后台线程处理耗时任务，主线程只需要负责调度显示。</p><p>CoreGraphics 框架可以通过图片上下文将绘制内容制作为一张位图，并且这个操作可以在非主线程执行。那么，当有 n 个绘制任务时，可以开辟多个线程在后台异步绘制，绘制成功拿到位图回到主线程赋值给 CALayer 的寄宿图属性。</p><p>这就是 YYAsyncLayer 框架的核心思想。</p><p>虽然多个线程异步绘制会消耗大量的内存，但是对于性能敏感界面来说，只要工程师控制好内存峰值，可以极大的提高交互流畅度。优化很多时候就是空间换时间，所谓鱼和熊掌不可兼得。这也说明了一个问题，实际开发中要做有针对性的优化，不可盲目跟风。</p><h3 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h3><p>类文件</p><pre><code class="hljs css"><span class="hljs-selector-tag">YYSentinel</span><span class="hljs-selector-class">.h</span> (<span class="hljs-selector-class">.m</span>)<span class="hljs-selector-tag">YYTransaction</span><span class="hljs-selector-class">.h</span> (<span class="hljs-selector-class">.m</span>)<span class="hljs-selector-tag">YYAsyncLayer</span><span class="hljs-selector-class">.h</span> (<span class="hljs-selector-class">.m</span>)</code></pre><h5 id="YYSentinel"><a href="#YYSentinel" class="headerlink" title="YYSentinel"></a>YYSentinel</h5><p>计数的类，自增int32_t类型变量value，是为了记录最新的布局请求标识，便于及时的放弃多余的绘制逻辑以减少开销。</p><p>在框架中的应用是，异步绘制操作之前取出value作为局部变量保存</p><pre><code class="hljs ceylon">int<span class="hljs-number">32_</span>t <span class="hljs-keyword">value</span> = sentinel.<span class="hljs-keyword">value</span>;</code></pre><p>然后定义isCancelled block判断是否取消绘制操作了</p><pre><code class="hljs gauss"><span class="hljs-keyword">BOOL</span> (^isCancelled)() = ^<span class="hljs-keyword">BOOL</span>() &#123;    <span class="hljs-comment">//value产生变化说明取消绘制操作</span>    <span class="hljs-keyword">return</span> value != sentinel.value;&#125;;</code></pre><p>取消绘制操作</p><pre><code class="hljs angelscript">- (<span class="hljs-built_in">void</span>)_cancelAsyncDisplay &#123;    <span class="hljs-comment">//对 value 进行自增，这样value就产生了变化</span><span class="hljs-string">    [_sentinel increase]</span>;&#125;</code></pre><h5 id="YYTransaction"><a href="#YYTransaction" class="headerlink" title="YYTransaction"></a>YYTransaction</h5><p>事务类，捕获主线程 runloop 的某个时机回调，用于处理异步绘制事件。</p><h5 id="YYAsyncLayer"><a href="#YYAsyncLayer" class="headerlink" title="YYAsyncLayer"></a>YYAsyncLayer</h5><p>继承自 CALayer ，封装了异步绘制的逻辑便于使用。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h5 id="YYSentinel-1"><a href="#YYSentinel-1" class="headerlink" title="YYSentinel"></a>YYSentinel</h5><p>.h</p><pre><code class="hljs less"><span class="hljs-variable">@interface</span> <span class="hljs-attribute">YYSentinel </span>: NSObject <span class="hljs-variable">@property</span> (readonly) int32_t value; <span class="hljs-selector-tag">-</span> (int32_t)<span class="hljs-selector-tag">increase</span>; @<span class="hljs-selector-tag">end</span></code></pre><p>.m</p><pre><code class="hljs arduino"><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;YYSentinel.h&quot;</span></span><span class="hljs-comment">// 若需要保证整形数值变量的线程安全，可以使用 OSAtomic 框架下的方法，它往往性能比使用各种“锁”更为优越，并且代码优雅。</span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;libkern/OSAtomic.h&gt;</span></span>@implementation YYSentinel &#123;    <span class="hljs-keyword">int32_t</span> _value;&#125;- (<span class="hljs-keyword">int32_t</span>)value &#123;    <span class="hljs-keyword">return</span> _value;&#125;<span class="hljs-comment">// 使用 OSAtomicIncrement32() 方法来对 value 执行自增。</span><span class="hljs-comment">// OSAtomicIncrement32() 是原子自增方法，线程安全。</span>- (<span class="hljs-keyword">int32_t</span>)increase &#123;    <span class="hljs-keyword">return</span> OSAtomicIncrement32(&amp;_value);&#125;@<span class="hljs-built_in">end</span></code></pre><h5 id="YYTransaction-1"><a href="#YYTransaction-1" class="headerlink" title="YYTransaction"></a>YYTransaction</h5><p>YYTransaction 使用集合来管理任务。</p><p>YYTransaction 做的事情就是记录一系列事件，并且在合适的时机调用这些事件。</p><h6 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h6><p>YYTransaction 有两个属性：</p><pre><code class="hljs less"><span class="hljs-variable">@interface</span> YYTransaction()<span class="hljs-variable">@property</span> (nonatomic, strong) id target;<span class="hljs-variable">@property</span> (nonatomic, assign) SEL selector;<span class="hljs-variable">@end</span>static NSMutableSet *transactionSet = nil;</code></pre><p>方法接收者 (target) 和方法 (selector)。<br>一个 YYTransaction就是一个任务，全局区的 transactionSet 集合就是用来存储这些任务。提交方法-commit 不过是初始配置并且将任务装入集合。</p><h6 id="合适的回调时机"><a href="#合适的回调时机" class="headerlink" title="合适的回调时机"></a>合适的回调时机</h6><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> YYTransactionSetup() &#123;    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;        transactionSet = [<span class="hljs-built_in">NSMutableSet</span> new];        <span class="hljs-built_in">CFRunLoopRef</span> runloop = <span class="hljs-built_in">CFRunLoopGetMain</span>();        <span class="hljs-built_in">CFRunLoopObserverRef</span> observer;                observer = <span class="hljs-built_in">CFRunLoopObserverCreate</span>(<span class="hljs-built_in">CFAllocatorGetDefault</span>(),                                           kCFRunLoopBeforeWaiting | kCFRunLoopExit,                                           <span class="hljs-literal">true</span>,      <span class="hljs-comment">// repeat</span>                                           <span class="hljs-number">0xFFFFFF</span>,  <span class="hljs-comment">// after CATransaction(2000000)</span>                                           YYRunLoopObserverCallBack, <span class="hljs-literal">NULL</span>);        <span class="hljs-built_in">CFRunLoopAddObserver</span>(runloop, observer, kCFRunLoopCommonModes);        <span class="hljs-built_in">CFRelease</span>(observer);    &#125;);&#125;</code></pre><p>在主线程的 RunLoop 中添加了一个 observer 监听，回调的时机是 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit ，即是主线程 RunLoop 循环即将进入休眠或者即将退出的时候。</p><p>observer 的优先级是 0xFFFFFF，优先级在 CATransaction 的后面.</p><p>回调里面做的事情：</p><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> YYRunLoopObserverCallBack(<span class="hljs-built_in">CFRunLoopObserverRef</span> observer, <span class="hljs-built_in">CFRunLoopActivity</span> activity, <span class="hljs-keyword">void</span> *info) &#123;    <span class="hljs-keyword">if</span> (transactionSet.count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">NSSet</span> *currentSet = transactionSet;    transactionSet = [<span class="hljs-built_in">NSMutableSet</span> new];    [currentSet enumerateObjectsUsingBlock:^(YYTransaction *transaction, <span class="hljs-built_in">BOOL</span> *stop) &#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> clang diagnostic push</span><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> clang diagnostic ignored <span class="hljs-meta-string">&quot;-Warc-performSelector-leaks&quot;</span></span>        [transaction.target performSelector:transaction.selector];<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> clang diagnostic pop</span>    &#125;];&#125;</code></pre><p>只是将集合中的任务遍历执行。</p><h6 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h6><p>重写 <code>isEqual:</code> 方法</p><pre><code class="hljs kotlin">- (BOOL)isEqual:(id)<span class="hljs-keyword">object</span> &#123;    <span class="hljs-keyword">if</span> (self == <span class="hljs-keyword">object</span>) <span class="hljs-keyword">return</span> YES;    <span class="hljs-keyword">if</span> (![<span class="hljs-keyword">object</span> isMemberOfClass:self.<span class="hljs-keyword">class</span>]) <span class="hljs-keyword">return</span> NO;    YYTransaction *other = <span class="hljs-keyword">object</span>;    <span class="hljs-keyword">return</span> other.selector == _selector &amp;&amp; other.target == _target;&#125;</code></pre><p>重写 hash 算法：</p><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSUInteger</span>)hash &#123;    <span class="hljs-keyword">long</span> v1 = (<span class="hljs-keyword">long</span>)((<span class="hljs-keyword">void</span> *)_selector);    <span class="hljs-keyword">long</span> v2 = (<span class="hljs-keyword">long</span>)_target;    <span class="hljs-keyword">return</span> v1 ^ v2;&#125;</code></pre><p>NSObject 类默认的 hash 值为 10 进制的内存地址，这里作者将 _selector和 _target 的内存地址进行一个位异或处理，意味着只要 _selector 和 _target 地址都相同时，hash 值就相同。</p><p>上面定义了<code>static NSMutableSet *transactionSet = nil;</code>，transactionSet是一个集合。</p><p>这么做的意义，是因为这里和其他编程语言一样 NSSet 是基于 hash 的集合，它是不能有重复元素的，而判断是否重复毫无疑问是使用 hash。作者通过重写hash算法来重新定义重复元素。</p><p>将 YYTransaction 的 hash值依托于 _selector 和 _target 的内存地址，那就意味着两点：<br>    1、同一个 YYTransaction 实例，_selector 和 _target 只要有一个内存地址不同，就会在集合中体现为两个值。<br>    2、不同的 YYTransaction 实例，_selector 和 _target 的内存地址都相同，在集合中的体现为一个值。</p><p>在这可以避免重复的方法调用。加入 transactionSet 中的事件会在 Runloop 即将进入休眠或者即将退出时遍历执行，相同的方法接收者 (_target) 和相同的方法 (_selector)，可以视为重复调用（这里的主要场景是避免重复绘制影响性能）。</p><p>举一个实际的例子：</p><p>当使用绘制来制作一个文本时，Font、Text等属性的改变都意味着要重绘，使用 YYTransaction 延迟了绘制的调用时机，并且它们在同一个 RunLoop 循环中，装入 NSSet 将直接合并为一个绘制任务，避免了重复的绘制。</p><h5 id="YYAsyncLayer-1"><a href="#YYAsyncLayer-1" class="headerlink" title="YYAsyncLayer"></a>YYAsyncLayer</h5><pre><code class="hljs less"><span class="hljs-variable">@interface</span> <span class="hljs-attribute">YYAsyncLayer </span>: CALayer <span class="hljs-variable">@property</span> BOOL displaysAsynchronously;<span class="hljs-variable">@end</span></code></pre><p>YYAsyncLayer 继承自 CALayer，对外暴露了一个方法可开闭是否异步绘制。</p><h6 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h6><pre><code class="hljs objectivec">- (<span class="hljs-keyword">instancetype</span>)init &#123;    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];    <span class="hljs-keyword">static</span> <span class="hljs-built_in">CGFloat</span> scale; <span class="hljs-comment">//global</span>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;        scale = [<span class="hljs-built_in">UIScreen</span> mainScreen].scale;    &#125;);    <span class="hljs-keyword">self</span>.contentsScale = scale;    _sentinel = [YYSentinel new];    _displaysAsynchronously = <span class="hljs-literal">YES</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;&#125;</code></pre><p>YYAsyncLayer 的 contentsScale 为屏幕的 scale，该属性是 物理像素 / 逻辑像素，这样可以充分利用不同设备的显示器分辨率，绘制更清晰的图像。但是若 contentsGravity 设置了可拉伸的类型，CoreAnimation 将会优先满足，而忽略掉 contentsScale。UIView 和 UIImageView 默认处理了它们内部 CALayer 的 contentsScale，所以除非是直接使用 CALayer 及其衍生类，都不用显式的配置 contentsScale。</p><p>同时还创建了一个 YYSentinel 实例。</p><p>默认开启异步绘制。</p><h6 id="重写绘制方法："><a href="#重写绘制方法：" class="headerlink" title="重写绘制方法："></a>重写绘制方法：</h6><pre><code class="hljs angelscript">- (<span class="hljs-built_in">void</span>)setNeedsDisplay &#123;<span class="hljs-string">    [self _cancelAsyncDisplay]</span>;<span class="hljs-string">    [super setNeedsDisplay]</span>;&#125;- (<span class="hljs-built_in">void</span>)display &#123;    <span class="hljs-keyword">super</span>.contents = <span class="hljs-keyword">super</span>.contents;<span class="hljs-string">    [self _displayAsync:_displaysAsynchronously]</span>;&#125;</code></pre><p>标记需要绘制时，会先取消目前的异步绘制。待下一轮runloop到来绘制时，通过 <code>_displayAsync:</code> 方法来进行异步绘制操作。<code>_displayAsync:</code> 方法后面分析。</p><h6 id="YYAsyncLayerDisplayTask"><a href="#YYAsyncLayerDisplayTask" class="headerlink" title="YYAsyncLayerDisplayTask"></a>YYAsyncLayerDisplayTask</h6><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">YYAsyncLayerDisplayTask</span> : <span class="hljs-title">NSObject</span></span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-keyword">void</span> (^willDisplay)(<span class="hljs-built_in">CALayer</span> *layer); <span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-keyword">void</span> (^display)(<span class="hljs-built_in">CGContextRef</span> context, <span class="hljs-built_in">CGSize</span> size, <span class="hljs-built_in">BOOL</span>(^isCancelled)(<span class="hljs-keyword">void</span>)); <span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-keyword">void</span> (^didDisplay)(<span class="hljs-built_in">CALayer</span> *layer, <span class="hljs-built_in">BOOL</span> finished); <span class="hljs-keyword">@end</span></code></pre><p><code>YYAsyncLayerDisplayTask</code> 是一个异步绘制任务。</p><p>通过 <code>willDisplay</code> 和 <code>didDisplay</code> 回调将要绘制和结束绘制时机，通过实现<code>display</code> 在代码块里面写业务绘制逻辑。</p><h6 id="YYAsyncLayerDelegate"><a href="#YYAsyncLayerDelegate" class="headerlink" title="YYAsyncLayerDelegate"></a>YYAsyncLayerDelegate</h6><pre><code class="hljs less"><span class="hljs-variable">@protocol</span> YYAsyncLayerDelegate &lt;NSObject&gt;<span class="hljs-variable">@required</span> - (YYAsyncLayerDisplayTask *)newAsyncDisplayTask;<span class="hljs-variable">@end</span></code></pre><p>通过协议提供数据源的方式，获取异步绘制的任务。</p><h5 id="异步绘制的核心逻辑"><a href="#异步绘制的核心逻辑" class="headerlink" title="异步绘制的核心逻辑"></a>异步绘制的核心逻辑</h5><p>去掉一些优化代码，主要做的事情如下：</p><pre><code class="hljs objectivec"><span class="hljs-built_in">dispatch_async</span>(YYAsyncLayerGetDisplayQueue(), ^&#123;            <span class="hljs-built_in">UIGraphicsBeginImageContextWithOptions</span>(size, opaque, scale);            <span class="hljs-built_in">CGContextRef</span> context = <span class="hljs-built_in">UIGraphicsGetCurrentContext</span>();             <span class="hljs-built_in">UIImage</span> *image = <span class="hljs-built_in">UIGraphicsGetImageFromCurrentImageContext</span>();            <span class="hljs-built_in">UIGraphicsEndImageContext</span>();            <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;                <span class="hljs-keyword">self</span>.contents = (__bridge <span class="hljs-keyword">id</span>)(image.CGImage);             &#125;);        &#125;);</code></pre><p>其实就是通过 <code>CoreGraphics</code> 在子线程中生成一个位图，然后进入主队列给 YYAsyncLayer 的 contents 赋值 CGImage 由 GPU 渲染过后提交到显示系统。</p><h5 id="及时的结束无用的绘制"><a href="#及时的结束无用的绘制" class="headerlink" title="及时的结束无用的绘制"></a>及时的结束无用的绘制</h5><p>前面提到的 <code>YYSentinel</code> 的作用已经说明。</p><p>在适当的地方进行自增value，然后在绘制过程中对比value是否发生变化来判断是否取消绘制操作。</p><p>很巧妙的实现。</p><h5 id="异步线程的管理"><a href="#异步线程的管理" class="headerlink" title="异步线程的管理"></a>异步线程的管理</h5><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_queue_t</span> YYAsyncLayerGetDisplayQueue() &#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> YYDispatchQueuePool_h</span>    <span class="hljs-keyword">return</span> YYDispatchQueueGetForQOS(<span class="hljs-built_in">NSQualityOfServiceUserInitiated</span>);<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_QUEUE_COUNT 16</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> queueCount;    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_queue_t</span> queues[MAX_QUEUE_COUNT];    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;    <span class="hljs-keyword">static</span> int32_t counter = <span class="hljs-number">0</span>;    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;        queueCount = (<span class="hljs-keyword">int</span>)[<span class="hljs-built_in">NSProcessInfo</span> processInfo].activeProcessorCount;        queueCount = queueCount &lt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;        <span class="hljs-keyword">if</span> ([<span class="hljs-built_in">UIDevice</span> currentDevice].systemVersion.floatValue &gt;= <span class="hljs-number">8.0</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSUInteger</span> i = <span class="hljs-number">0</span>; i &lt; queueCount; i++) &#123;                dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, <span class="hljs-number">0</span>);                queues[i] = dispatch_queue_create(<span class="hljs-string">&quot;com.ibireme.yykit.render&quot;</span>, attr);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSUInteger</span> i = <span class="hljs-number">0</span>; i &lt; queueCount; i++) &#123;                queues[i] = dispatch_queue_create(<span class="hljs-string">&quot;com.ibireme.yykit.render&quot;</span>, DISPATCH_QUEUE_SERIAL);                dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>));            &#125;        &#125;    &#125;);    int32_t cur = OSAtomicIncrement32(&amp;counter);    <span class="hljs-keyword">if</span> (cur &lt; <span class="hljs-number">0</span>) cur = -cur;    <span class="hljs-keyword">return</span> queues[(cur) % queueCount];<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> MAX_QUEUE_COUNT</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>&#125;</code></pre><h6 id="要点-1-：串行队列数量和处理器数量相同"><a href="#要点-1-：串行队列数量和处理器数量相同" class="headerlink" title="要点 1 ：串行队列数量和处理器数量相同"></a>要点 1 ：串行队列数量和处理器数量相同</h6><p>一个 n 核设备同一时刻最多能 并行 执行 n 个任务，也就是最多有 n 个线程是相互不竞争 CPU 资源的。</p><p>开辟的线程过多，超过了处理数量，实际上某些并行的线程之间就可能竞争同一个处理器的资源，频繁的切换上下文也会消耗处理器资源。</p><p>而串行队列中只有一个线程，该框架中，作者使用和处理器相同数量的串行队列来轮询处理异步任务，有效的减少了线程调度操作。</p><h6 id="要点-2-：创建串行队列，设置优先级"><a href="#要点-2-：创建串行队列，设置优先级" class="headerlink" title="要点 2 ：创建串行队列，设置优先级"></a>要点 2 ：创建串行队列，设置优先级</h6><p>在 8.0 以上的系统，队列的优先级为 QOS_CLASS_USER_INITIATED，低于用户交互相关的 QOS_CLASS_USER_INTERACTIVE。</p><p>在 8.0 以下的系统，通过 dispatch_set_target_queue() 函数设置优先级为 DISPATCH_QUEUE_PRIORITY_DEFAULT (第二个参数如果使用串行队列会强行将我们创建的所有线程串行执行任务)。</p><p>可以猜测主队列的优先级是大于或等于 QOS_CLASS_USER_INTERACTIVE的，让这些串行队列的优先级低于主队列，避免框架创建的线程和主线程竞争资源。</p><h6 id="要点-3-：轮询返回队列"><a href="#要点-3-：轮询返回队列" class="headerlink" title="要点 3 ：轮询返回队列"></a>要点 3 ：轮询返回队列</h6><p>使用原子自增函数 OSAtomicIncrement32() 对局部静态变量 counter进行自增，然后通过取模运算轮询返回队列。</p><p>注意这里使用了一个判断：if (cur &lt; 0) cur = -cur;，当 cur 自增越界时就会变为负数最大值（在二进制层面，是用正整数的反码加一来表示其负数的）。</p><h6 id="为什么要使用-n-个串行队列实现并发"><a href="#为什么要使用-n-个串行队列实现并发" class="headerlink" title="为什么要使用 n 个串行队列实现并发"></a>为什么要使用 n 个串行队列实现并发</h6><p>为什么这里需要使用 n 个串行队列来调度，而不用一个并行队列。</p><p>主要是因为并行队列无法精确的控制线程数量，很有可能创建过多的线程，导致 CPU 线程调度过于频繁，影响交互性能。</p><p>可能会想到用信号量 (dispatch_semaphore_t) 来控制并发，然而这样只能控制并发的任务数量，而不能控制线程数量，并且使用起来不是很优雅。而使用串行队列就很简单了，我们可以很明确的知道自己创建的线程数量，一切皆在掌控之中。</p><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p><a href="https://www.jianshu.com/p/154451e4bd42">YYAsyncLayer 源码剖析：异步绘制</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图像和图形的最佳实践（WWDC 2018 session 219）</title>
    <link href="/2019/10/20/%E5%9B%BE%E5%83%8F%E5%92%8C%E5%9B%BE%E5%BD%A2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%88WWDC-2018-session-219%EF%BC%89/"/>
    <url>/2019/10/20/%E5%9B%BE%E5%83%8F%E5%92%8C%E5%9B%BE%E5%BD%A2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%88WWDC-2018-session-219%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="UIImage和UIImageView"><a href="#UIImage和UIImageView" class="headerlink" title="UIImage和UIImageView"></a>UIImage和UIImageView</h3><p>UIImage在UIKit中表示一个图形的内容，而UIImageView在UIKit中用来呈现一个视图。但是在这之外还有一个隐藏的、影响程序性能的过程，叫做解码(Decode)。</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2377" alt="408ae032ad58fa3ed7567c071056843a.png"></p><h5 id="图片的解码"><a href="#图片的解码" class="headerlink" title="图片的解码"></a>图片的解码</h5><p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。</p><p>如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p><p>在了解Decode的过程中，我们首先要了解一个概念：缓冲区(Buffer)。</p><h5 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区(Buffer)"></a>缓冲区(Buffer)</h5><ol><li>缓冲区是在内存中连续的区域。</li><li>通常被视为元素序列。</li></ol><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2380" alt="6234b17718adc25d94d92591359cb113.png"></p><h6 id="图像缓冲区-Image-Buffer-："><a href="#图像缓冲区-Image-Buffer-：" class="headerlink" title="图像缓冲区(Image Buffer)："></a>图像缓冲区(Image Buffer)：</h6><p>图像缓冲区中每个元素表示的是图像中一个像素的颜色信息。所以，该Buffer在内存中的大小与图像大小成正比。</p><h6 id="帧缓冲区-Frame-Buffer-："><a href="#帧缓冲区-Frame-Buffer-：" class="headerlink" title="帧缓冲区(Frame Buffer)："></a>帧缓冲区(Frame Buffer)：</h6><p>帧缓冲区是保存应用实际呈现输出的缓冲区。<br>在应用更新视图层次结构时，UIKit会把应用程序的Window以及子视图渲染到帧缓冲区中。这个更新频率在iPhone上是60FPS，在iPad上是120FPS。<br><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2379" alt="5d0b29cb1cf62a7f88ed9d104971a358.gif"></p><h6 id="数据缓冲区-Data-Buffer"><a href="#数据缓冲区-Data-Buffer" class="headerlink" title="数据缓冲区(Data Buffer)"></a>数据缓冲区(Data Buffer)</h6><p>数据缓冲区为保存一系列bytes数据的缓冲区。<br>在图像例子中，数据缓冲区就是保存从网络下载或者保存在磁盘中的图像的数据，这些数据并不直接描述每一个像素的信息。<br><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2378" alt="f70e8ce6d59fbd8b9437a04e4e05e48f.png"></p><h5 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h5><h6 id="加载准备"><a href="#加载准备" class="headerlink" title="加载准备"></a>加载准备</h6><p>准备一个图像元数据，一个UIImage，以及一个加载在视图上的UIImageView，如下：<br><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2381" alt="facc0c35e7982012157d52ed9c5323f8.png"></p><h6 id="获取像素信息"><a href="#获取像素信息" class="headerlink" title="获取像素信息"></a>获取像素信息</h6><p>为了将图像中每个像素信息填充到Frame Buffer中，我们需要得到图像像素信息。</p><p>UIImage会为我们处理这一点：UIImage会创建一个与图片大小一致的Image Buffer用来存储解码(Decode)之后的图像像素信息。</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2382" alt="00656289e1fe1ef8f2e0ad2c3739ffab.png"></p><h6 id="显示在屏幕上"><a href="#显示在屏幕上" class="headerlink" title="显示在屏幕上"></a>显示在屏幕上</h6><p>UIImageView读取UIImage创建的Image Buffer数据，交由UIKit显示。UIKit会对像素数据缩放到显示大小进行显示。</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2383" alt="048fdec73f278bcdd057bc0304705253.png"></p><p>在加载过程中，UIKit会重复多次的要求UIImageView去进行渲染，这就造成了UIImage会多次的解码Data Buffer。</p><p>为了解决这个问题，UIImage会只进行一次Data Buffer的解码，在解码之后，会挂起解码后的Image Buffer。</p><p>所以，在这种情况下，应用对于每一个UIImage解码后，都会在内存中挂起一个Image Buffer。</p><p>由于Image Buffer与图像大小成正比，所以在加载大图片时，应用程序会在内存中挂起很多大的Image Buffer，这可能会造成操作系统介入，并最终杀死应用。</p><h5 id="下采样-downsampling"><a href="#下采样-downsampling" class="headerlink" title="下采样(downsampling)"></a>下采样(downsampling)</h5><p>针对于我们上述提到的问题，我们可以采用叫做下采用(downsampling)的技术。</p><p>我们注意到，我们最终显示在屏幕上的视图往往比实际图片的尺寸要小，而通常情况下，Core Animation Framework会负责缩小图像。</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2384" alt="71a31df9d652df1bdcf9cc9021b8b3db.png"></p><p>现在要做的，本质上是把缩放图像操作捕获为一个叫缩略图的对象。由于减小了Image Buffer的大小，进而减小了在加载图片中的使用的内存总大小。</p><p>同时，我们在解码后，将图片像素信息交给UIImageView去渲染至屏幕后，可以丢弃掉对应的Data Buffer，进一步减少内存的使用。</p><p>这个过程如下图：</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2385" alt="c8194124dbec3c8245dd3ae3189e8ce9.gif"></p><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2386" alt="d6d28e69f0db0002580d99cf353a4431.png"></p><p>几个重要的点：</p><ol><li>创建CGImageSourceRef</li><li>计算需要渲染至屏幕的真实尺寸、</li><li>获取缩略图</li></ol><h6 id="下采样之后效果"><a href="#下采样之后效果" class="headerlink" title="下采样之后效果"></a>下采样之后效果</h6><p>通过以上的改进方式，可以大幅度的缩减内存的使用。以下为一组测试数据：<br>测试环境：Xcode9.4，iPhone 6s Plus, 5184*3456的5.1MB大小的JPG格式图片。</p><ol><li>不使用改进方法，消耗内存为：49.3M</li><li>使用改进方法，消耗内存为：9.4M</li></ol><h5 id="针对滚动视图的优化"><a href="#针对滚动视图的优化" class="headerlink" title="针对滚动视图的优化"></a>针对滚动视图的优化</h5><p>如果我们需要一个滚动视图来展示一大组质量很大的图片时，我们也会遇到内存过高的问题，接下来我们以UICollectionView加载图片来做分析和优化。</p><h6 id="使用下采样-downsampling-的方式优化"><a href="#使用下采样-downsampling-的方式优化" class="headerlink" title="使用下采样(downsampling)的方式优化"></a>使用下采样(downsampling)的方式优化</h6><p>首先我们采用我们上一步优化图片的方式来为每一个cell中的图片进行优化，代码可能如下：</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2387" alt="7e545fe88c4125e701978615815333f0.png"></p><p>这样我们为每一个cell上的图片显示进行了优化，进而使得整体内存使用有一个明显的降低。</p><p>但是，这样会引起另一个问题：如果此时滚动视图，CPU可能会很快的将所需展示的内容渲染到帧缓冲区，但是如果滚动过快，CPU还需参与Core Graphics对于新图像的解帧，这个操作是非常耗时的，这样就可能会造成在硬件读取帧缓冲区数据显示至屏幕时，帧缓冲区数据并没有准备好，进而导致用户视角中的卡顿。另外对于电池来说，在CPU不稳定时，可能会影响到电池使用寿命。</p><h6 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h6><p>有两种技术可以帮助我们解决上述问题。</p><ol><li>预取(prefetching)：在某一时刻，我们不需要某个cell，但是在不久的将来会需要这个cell，所以可以把某些工作提前至这个时刻来进行。</li><li>后台执行(performing work in the background)。</li></ol><p>针对于UICollectionView，我们可以做以下处理：</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2388" alt="489fb1b6693c03fc68a08655a3b23e53.png">  </p><p>我们为预取的cell进行在后台即全局异步队列(global<br>asynchronous queues)的图像解码，这是我们提到的两种优化技术。</p><p>但是，在使用全局异步队列的时候，可能会出现线程爆炸的问题：如果我们一次性处理多张图像，但是设备只有2个CPU时，此时GCD会创建新的线程来处理解码工作。创建新线程以及在不同线程之间切换是十分消耗时间和资源的。</p><h6 id="解决线程爆炸问题"><a href="#解决线程爆炸问题" class="headerlink" title="解决线程爆炸问题"></a>解决线程爆炸问题</h6><p>我们可以将解码操作异步的分派到串行队列中，如下图：</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2389" alt="57beaadf105a2ca2d77631641f2415c9.png"></p><p>这样做可能使得某些图像的解码过程延后，但是更多的是减少了在线程切换过程中浪费的时间和资源。</p><p>至此，我们完成了对于滚动视图加载多张图片的优化。</p><h5 id="图片资源的优化"><a href="#图片资源的优化" class="headerlink" title="图片资源的优化"></a>图片资源的优化</h5><p>在目前的程序中，可以展示的图像资源来源可能有一下几种：</p><ol><li>存储在Image Assets中</li><li>存储在Application或者Bundle的包中</li><li>存储在沙盒的Document或者Cache文件中</li><li>从网络下载的数据中</li></ol><p>对于程序中自带的图像资源，苹果官方推荐我们使用Image Assets来存储，以下是使用该方式的几个优点：</p><ol><li>Image Assets针对基于名称和特性的查找进行了优化，它比在磁盘上搜索文件要快。</li><li>在管理缓冲区方面也有优化。</li><li>允许对设备安装包进行优化，在下载App的时候会只下载能最高效果显示在对应设备的图像资源，从而减小安装包大小。</li><li>对Vector Artwork的支持。</li></ol><h6 id="Vector-Artwork"><a href="#Vector-Artwork" class="headerlink" title="Vector Artwork"></a>Vector Artwork</h6><p>Vector Artwork是iOS 11引入的新特性。我们可以在Image Assets中勾选Preserve Vector Data来启用它。如果启用了Vector Artwork的话，当我们将图像显示到一个比它原始尺寸大或者小的视图中时，这个图像不会变的模糊。因为显示的图像是从矢量图形中重新光栅化而来的，从而使得图像有清晰的边缘。</p><p>启用Vector Artwork后，图像的处理方式和之前图片的处理方式类似，只是将解码阶段变为了光栅化阶段，光栅化阶段将矢量数据转换为位图数据，进而供帧缓冲区读取。</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2390" alt="261beb86f4101804b5cfdf75201997c4.png"></p><p>如果我们把应用中所有的图像资源进行了Preserve Vector Data处理的话，会造成一些CPU的使用。<br>所以Xcode对这些情况做了一些处理：如果选中了Preserve Vector Data选项，但是在视图上展示为原始尺寸大小时，Image Assets实际上已经完成了原始尺寸的光栅化，并把相关数据保存在Image Assets中了，所以这种情况可以直接对存储的数据进行解码，而不进行光栅化。</p><p>另外一个建议是：如果计划展示的尺寸为固定的几个尺寸，那么不要依赖Preserve Vector Data，而是准备好对应尺寸的图像资源，从而加快CPU对图像资源的处理。</p><h3 id="自定义绘制内容"><a href="#自定义绘制内容" class="headerlink" title="自定义绘制内容"></a>自定义绘制内容</h3><p>我们有时需要在程序中进行一些自定义的绘制，例如绘制一个如下样式的视图：</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2391" alt="ff0b012d2fa40975005f5be41176c647.png"></p><p>我们可以继承UIView，然后在draw方法中进行相应的绘制：</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2392" alt="bbe84f6a2a0164c69e23ee7590de4d55.png"></p><p>UIView是基于CALayer来显示内容的；</p><p>而对于UIImageView来说，UIImageView会将UIImage解码后的数据交给CALayer来作为内容显示；</p><p>而对于draw来说，CALayer会创建一个与图像大小成正比的backing store来存储图像数据，然后将图像数据拷贝至backing store中，然后将backing store中的内容绘制到帧缓冲区中。</p><p>通过重写draw方法可能会造成多余的内存消耗以及数据的拷贝.</p><h5 id="Backing-Store"><a href="#Backing-Store" class="headerlink" title="Backing Store"></a>Backing Store</h5><p>重写draw方法时，会触发创建Backing Store，此时的Backing Store的大小与视图的像素大小成正比。</p><p>在iOS12中，Backing Store将会使用动态增长的方式来减少内存的使用。在以前的iOS版本中，我们可以设置CALayer的contentsFromat属性来指定Core Animation Framework在绘制时用到的颜色长度，这个设置会关闭iOS12中关于Backing Store的设置。</p><h5 id="建议实现方式"><a href="#建议实现方式" class="headerlink" title="建议实现方式"></a>建议实现方式</h5><p>对于我们需要自定义绘制的视图，我们应该减少Backing Store的使用。</p><p>通常的做法是将一个大视图构建为多个小视图来实现；<br>同时，系统提供的经过优化的视图属性也不会造成多余内存的使用（例如UIView的backgroundColor属性，就不会创建Backing Store。此时需要注意，使用pattern color时是一个例外，可以使用UIImageView作为UIView的子视图来替代这一效果）。</p><h5 id="将大视图构建为多个小视图"><a href="#将大视图构建为多个小视图" class="headerlink" title="将大视图构建为多个小视图"></a>将大视图构建为多个小视图</h5><p>我们可以构建为以下层级：</p><p><img src="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2393" alt="d5e68ec0d562fc3d97870464c8cd875c.png"></p><h6 id="圆角处理"><a href="#圆角处理" class="headerlink" title="圆角处理"></a>圆角处理</h6><p>在我们要进行圆角处理时，使用CALayer的cornerRadius属性，该属性不会引起多余的内存使用。而对于使用maskView和maskLayer来说，会使用到额外的内存空间。</p><p>同时对于圆角之外的透明区域为复杂的不规则形状且cornerRadius满足不了需求时，可以使用UIImageView配合Resizeable的UIImage来进行处理。</p><h6 id="Icon的实现"><a href="#Icon的实现" class="headerlink" title="Icon的实现"></a>Icon的实现</h6><p>Icon可以使用UIImageView来显示。</p><p>为了达到UIImage的复用，UIImageView支持对单色图像着色，同时可以直接渲染到帧缓冲区中。</p><p>这个设置需要对UIImage进行renderingMode的设置或者在Image Assets中进renderingMode设置。</p><p>最后，为UIImageView设置tintColor来完成最终颜色渲染。</p><h6 id="UILabel的优化"><a href="#UILabel的优化" class="headerlink" title="UILabel的优化"></a>UILabel的优化</h6><p>UILabel对于显示单色字符串做了优化处理，可以节省75%大小的Backing Store的使用。</p><p>UILabel对于多彩字符串以及emoji进行了动态增长Backing Store的优化。</p><h3 id="简单讲述在应用中使用先进的CPU和GPU技术。"><a href="#简单讲述在应用中使用先进的CPU和GPU技术。" class="headerlink" title="简单讲述在应用中使用先进的CPU和GPU技术。"></a>简单讲述在应用中使用先进的CPU和GPU技术。</h3><h5 id="Advanced-Image-Effects"><a href="#Advanced-Image-Effects" class="headerlink" title="Advanced Image Effects"></a>Advanced Image Effects</h5><ol><li>实时处理图像时考虑Core Image。</li><li>尽量使用GPU来处理图像，进而解放CPU。</li><li>使用CIImage创建UIImage，并交由UIImageView去展示，这个过程会默认由GPU去处理，减少对CPU的使用。</li></ol><h5 id="Advanced-Image-Processing"><a href="#Advanced-Image-Processing" class="headerlink" title="Advanced Image Processing"></a>Advanced Image Processing</h5><ol><li>使用CVPixelBuffer将数据移动到Metal, Vision和Accelerate等框架。</li><li>使用最好的初始值设定项（不要重复执行已经完成的工作）。</li><li>防止在GPU和CPU直接来回切换。</li><li>确保交给Accelerate的buffers是正确的格式。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>异步的进行预处理。</li><li>使用UIImageView和UILabel来减少Backing Store的使用。</li><li>不要禁止自定义绘制时系统做的新优化。</li><li>使用Image Assets来存储图像。</li><li>如果要展示相同图片的不同尺寸，不要过多依赖Preserve Vector Data。</li></ol><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p><a href="https://blog.csdn.net/TuGeLe/article/details/81137995">图像和图形的最佳实践（WWDC 2018 session 219）</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2018/219/">WWDC 2018 session 219</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS离屏渲染研究</title>
    <link href="/2019/10/20/iOS%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E7%A0%94%E7%A9%B6/"/>
    <url>/2019/10/20/iOS%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h3><h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><p>如果要在显示屏上显示内容，我们至少需要一块与屏幕像素数据量一样大的frame buffer，作为像素数据存储区域，而这也是GPU存储渲染结果的地方。如果有时因为面临一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。</p><p>简单说就是：在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p><h6 id="离屏渲染消耗性能的原因"><a href="#离屏渲染消耗性能的原因" class="headerlink" title="离屏渲染消耗性能的原因"></a>离屏渲染消耗性能的原因</h6><ol><li>需要创建新的缓冲区</li><li>离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕</li></ol><h3 id="离屏渲染是在哪一步进行的？为什么？"><a href="#离屏渲染是在哪一步进行的？为什么？" class="headerlink" title="离屏渲染是在哪一步进行的？为什么？"></a>离屏渲染是在哪一步进行的？为什么？</h3><p>1、CPU”离屏渲染“</p><p>在UIView中实现了drawRect方法，就算它的函数体内部实际没有代码，系统也会为这个view申请一块内存区域，等待CoreGraphics可能的绘画操作。</p><p>对于类似这种“新开一块CGContext来画图“的操作，有很多文章和视频也称之为“离屏渲染”（因为像素数据是暂时存入了CGContext，而不是直接到了frame buffer）。进一步来说，其实所有CPU进行的光栅化操作（如文字渲染、图片解码），都无法直接绘制到由GPU掌管的frame buffer，只能暂时先放在另一块内存之中，说起来都属于“离屏渲染”。</p><p>根据苹果工程师的说法CPU渲染就是俗称的“软件渲染”，而真正的离屏渲染发生在GPU。</p><p>2、GPU离屏渲染</p><p>对于每一层layer，要么能找到一种通过单次遍历就能完成渲染的算法，要么就不得不另开一块内存，借助这个临时中转区域来完成一些更复杂的、多次的修改/剪裁操作，这时就离屏渲染了。</p><h3 id="设置cornerRadius一定会触发离屏渲染吗？"><a href="#设置cornerRadius一定会触发离屏渲染吗？" class="headerlink" title="设置cornerRadius一定会触发离屏渲染吗？"></a>设置cornerRadius一定会触发离屏渲染吗？</h3><p>不会</p><h3 id="常见离屏渲染场景"><a href="#常见离屏渲染场景" class="headerlink" title="常见离屏渲染场景"></a>常见离屏渲染场景</h3><h6 id="1、-cornerRadius-clipsToBounds"><a href="#1、-cornerRadius-clipsToBounds" class="headerlink" title="1、 cornerRadius+clipsToBounds"></a>1、 cornerRadius+clipsToBounds</h6><p>1、将一个layer的内容裁剪成圆角，可能不存在一次遍历就能完成的方法<br>2、容器的子layer因为父容器有圆角，那么也会需要被裁剪，而这时它们还在渲染队列中排队，尚未被组合到一块画布上，自然也无法统一裁剪</p><p>此时我们就不得不开辟一块独立于frame buffer的空白内存，先把容器以及其所有子layer依次画好，然后把四个角“剪”成圆形，再把结果画到frame buffer中。这就造成了GPU的离屏渲染。</p><h6 id="2、shadow"><a href="#2、shadow" class="headerlink" title="2、shadow"></a>2、shadow</h6><p>原因在于，虽然layer本身是一块矩形区域，但是阴影默认是作用在其中”非透明区域“的，而且需要显示在所有layer内容的下方，因此根据画家算法必须被渲染在先。但矛盾在于此时阴影的本体（layer和其子layer）都还没有被组合到一起，怎么可能在第一步就画出只有完成最后一步之后才能知道的形状呢？这样一来又只能另外申请一块内存，把本体内容都先画好，再根据渲染结果的形状，添加阴影到frame buffer，最后把内容画上去（这只是我的猜测，实际情况可能更复杂）。</p><p>不过如果我们能够预先告诉CoreAnimation（通过shadowPath属性）阴影的几何形状，那么阴影当然可以先被独立渲染出来，不需要依赖layer本体，也就不再需要离屏渲染了。</p><h6 id="3、group-opacity"><a href="#3、group-opacity" class="headerlink" title="3、group opacity"></a>3、group opacity</h6><p>alpha并不是分别应用在每一层之上，而是只有到整个layer树画完之后，再统一加上alpha，最后和底下其他layer的像素进行组合。显然也无法通过一次遍历就得到最终结果。将一对蓝色和红色layer叠在一起，然后在父layer上设置opacity=0.5，并复制一份在旁边作对比。左边关闭group opacity，右边保持默认（从iOS7开始，如果没有显式指定，group opacity会默认打开），然后打开offscreen rendering的调试，我们会发现右边的那一组确实是离屏渲染了。</p><h6 id="4、mask"><a href="#4、mask" class="headerlink" title="4、mask"></a>4、mask</h6><p>我们知道mask是应用在layer和其所有子layer的组合之上的，而且可能带有透明度，那么其实和group opacity的原理类似，不得不在离屏渲染中完成。</p><h6 id="5、UIBlurEffect"><a href="#5、UIBlurEffect" class="headerlink" title="5、UIBlurEffect"></a>5、UIBlurEffect</h6><p>同样无法通过一次遍历完成，其原理在WWDC中提到。</p><h6 id="6、shouldRasterize。一旦被设置为true"><a href="#6、shouldRasterize。一旦被设置为true" class="headerlink" title="6、shouldRasterize。一旦被设置为true"></a>6、shouldRasterize。一旦被设置为true</h6><p>Render Server就会强制把layer的渲染结果（包括其子layer，以及圆角、阴影、group opacity等等）保存在一块内存中，这样一来在下一帧仍然可以被复用，而不会再次触发离屏渲染。</p><p>注意：</p><ol><li>shouldRasterize的主旨在于降低性能损失，但总是至少会触发一次离屏渲染。</li><li>离屏渲染缓存有空间上限，最多不超过屏幕总像素的2.5倍大小</li><li>一旦缓存超过100ms没有被使用，会自动被丢弃</li><li>layer的内容（包括子layer）必须是静态的，因为一旦发生变化（如resize，动画），之前辛苦处理得到的缓存就失效了。</li><li>其实除了解决多次离屏渲染的开销，shouldRasterize在另一个场景中也可以使用：如果layer的子结构非常复杂，渲染一次所需时间较长，同样可以打开这个开关，把layer绘制到一块缓存，然后在接下来复用这个结果，这样就不需要每次都重新绘制整个layer树了</li></ol><h6 id="7、其他"><a href="#7、其他" class="headerlink" title="7、其他"></a>7、其他</h6><p>类似allowsEdgeAntialiasing等等也可能会触发离屏渲染，</p><p>原理也都是类似：如果你无法仅仅使用frame buffer来画出最终结果，那就只能另开一块内存空间来储存中间结果。这些原理并不神秘。</p><h3 id="什么时候需要CPU渲染"><a href="#什么时候需要CPU渲染" class="headerlink" title="什么时候需要CPU渲染"></a>什么时候需要CPU渲染</h3><p>渲染性能的调优，其实始终是在做一件事：平衡CPU和GPU的负载，让他们尽量做各自最擅长的工作。</p><p>绝大多数情况下，得益于GPU针对图形处理的优化，我们都会倾向于让GPU来完成渲染任务，而给CPU留出足够时间处理各种各样复杂的App逻辑。</p><p>为此Core Animation做了大量的工作，尽量把渲染工作转换成适合GPU处理的形式（也就是所谓的硬件加速，如layer composition，设置backgroundColor等等）。</p><p>但是对于一些情况，如文字（CoreText使用CoreGraphics渲染）和图片（ImageIO）渲染，由于GPU并不擅长做这些工作，不得不先由CPU来处理好以后，再把结果作为texture传给GPU。</p><p>一个典型的例子是，我们经常会使用CoreGraphics给图片加上圆角（将图片中圆角以外的部分渲染成透明）。整个过程全部是由CPU完成的。这样一来既然我们已经得到了想要的效果，就不需要再另外给图片容器设置cornerRadius。另一个好处是，我们可以灵活地控制裁剪和缓存的时机，巧妙避开CPU和GPU最繁忙的时段，达到平滑性能波动的目的。</p><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NzMwODI0MA==&mid=2647764329&idx=1&sn=7e13a167b7d4df4d071928248d9531b7&chksm=8887d656bff05f40a41e614493103e4ddaecbd7caaf81b6db4019684ffffefd8bdbe1d068179&mpshare=1&scene=23&srcid=1211WQgUISoJ055okBhVGJaJ&sharer_sharetime=1576054080266&sharer_shareid=fc8016a1ffcf846e48e1c7a21f07026a%23rd">iOS离屏渲染研究</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS 高效切圆角方法总结</title>
    <link href="/2019/10/20/iOS%20%E9%AB%98%E6%95%88%E5%88%87%E5%9C%86%E8%A7%92%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2019/10/20/iOS%20%E9%AB%98%E6%95%88%E5%88%87%E5%9C%86%E8%A7%92%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="UIView设置圆角"><a href="#UIView设置圆角" class="headerlink" title="UIView设置圆角"></a>UIView设置圆角</h3><h5 id="四个圆角"><a href="#四个圆角" class="headerlink" title="四个圆角"></a>四个圆角</h5><p>对于 contents 无内容或者内容的背景透明(无涉及到圆角以外的区域)的layer，直接设置layer的 backgroundColor 和 cornerRadius 属性来绘制圆角:</p><ol><li>UIView的contents无内容可以直接通过设置cornerRadius达到效果。</li><li>UILable的contents也一样，所以也可通过<br>设置cornerRadius达到效果。不过label不能直接设置backgroundColor，因为这样设置的是contents的backgroundColor，需要设置layer. backgroundColor。 </li></ol><pre><code class="hljs stata">UIView *<span class="hljs-keyword">view</span> = [[UIView alloc] init];<span class="hljs-keyword">view</span>.backgroundColor = [UIColor blackColor];<span class="hljs-keyword">view</span>.layer.cornerRadius = 3.f;<span class="hljs-comment">// 以下两行，任写一行</span><span class="hljs-keyword">view</span>.layer.masksToBounds = <span class="hljs-keyword">NO</span>;<span class="hljs-keyword">view</span>.clipToBounds = <span class="hljs-keyword">NO</span>;<span class="hljs-comment">// 以下两行，千万不要加！</span><span class="hljs-keyword">view</span>.layer.masksToBounds = YES;<span class="hljs-keyword">view</span>.clipToBounds = YES;</code></pre><p>注意点：UIView 只要设置图层的 cornerRadius 属性即可（不明白的话，可以看看官方文档里对 cornerRadius 的描述），如果设置 layer.masksToBounds = YES，会造成不必要的离屏渲染。 </p><h5 id="单独某个方向的圆角-特殊情况需要设置layer-masksToBounds，就不要通过cornerRadius方式了"><a href="#单独某个方向的圆角-特殊情况需要设置layer-masksToBounds，就不要通过cornerRadius方式了" class="headerlink" title="单独某个方向的圆角/特殊情况需要设置layer.masksToBounds，就不要通过cornerRadius方式了"></a>单独某个方向的圆角/特殊情况需要设置layer.masksToBounds，就不要通过cornerRadius方式了</h5><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">UIView</span> (<span class="hljs-title">RounderCorner</span>)</span>- (<span class="hljs-keyword">void</span>)hh_addRounderCornerWithRadius:(<span class="hljs-built_in">CGFloat</span>)radius size:(<span class="hljs-built_in">CGSize</span>)size corners:(<span class="hljs-built_in">UIRectCorner</span>)corner&#123;    <span class="hljs-comment">//绘制一个圆角图片</span>    <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> hh_corver:.....];        <span class="hljs-built_in">UIImageView</span> *imageView = [[<span class="hljs-built_in">UIImageView</span> alloc] initWithFrame:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, size.width, size.height)];    [imageView setImage:image];    [<span class="hljs-keyword">self</span> insertSubview:imageView atIndex:<span class="hljs-number">0</span>];&#125;</code></pre><h3 id="文本类视图"><a href="#文本类视图" class="headerlink" title="文本类视图"></a>文本类视图</h3><h5 id="UITextField"><a href="#UITextField" class="headerlink" title="UITextField"></a>UITextField</h5><p>UITextField有两种实现方法</p><pre><code class="hljs objectivec"><span class="hljs-comment">// 天然支持设置圆角边框</span><span class="hljs-built_in">UITextField</span> *textField = [[<span class="hljs-built_in">UITextField</span> alloc] init];textField.borderStyle = <span class="hljs-built_in">UITextBorderStyleRoundedRect</span>;</code></pre><pre><code class="hljs mel"><span class="hljs-comment">// 与 UIView 类似</span>UITextField *<span class="hljs-keyword">textField</span> = [[UITextField alloc] init];<span class="hljs-keyword">textField</span>.layer.cornerRadius = cornerRadius;</code></pre><h5 id="UITextView"><a href="#UITextView" class="headerlink" title="UITextView"></a>UITextView</h5><pre><code class="hljs objectivec"><span class="hljs-comment">// 与 UIView 类似</span><span class="hljs-built_in">UITextView</span> *textView = [[<span class="hljs-built_in">UITextView</span> alloc] init];textView.layer.cornerRadius = cornerRadius;</code></pre><h5 id="UILabel"><a href="#UILabel" class="headerlink" title="UILabel"></a>UILabel</h5><pre><code class="hljs delphi">UILabel *<span class="hljs-keyword">label</span> = [[UILabel alloc] init];<span class="hljs-comment">// 重点在此！！设置视图的图层背景色，千万不要直接设置 label.backgroundColor</span><span class="hljs-keyword">label</span>.layer.backgroundColor = [UIColor grayColor].CGColor;<span class="hljs-keyword">label</span>.layer.cornerRadius = cornerRadius;</code></pre><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h5 id="UIButton"><a href="#UIButton" class="headerlink" title="UIButton"></a>UIButton</h5><p>说明：UIButton 的背景图片，如果是复杂的图片，可以依靠 UI 切图来实现。如果是简单的纯色背景图片，可以利用代码绘制带圆角的图片。</p><pre><code class="hljs objectivec"><span class="hljs-built_in">UIButton</span> *button = [<span class="hljs-built_in">UIButton</span> buttonWithType:<span class="hljs-built_in">UIButtonTypeCustom</span>];<span class="hljs-comment">// 设置 UIButton 的背景图片。</span>[button setBackgroundImage:image forState:<span class="hljs-built_in">UIControlStateNormal</span>];</code></pre><p>背景图片绘制方法</p><pre><code class="hljs objectivec">+ (<span class="hljs-built_in">UIImage</span> *)pureColorImageWithSize:(<span class="hljs-built_in">CGSize</span>)size color:(<span class="hljs-built_in">UIColor</span> *)color cornRadius:(<span class="hljs-built_in">CGFloat</span>)cornRadius &#123;  <span class="hljs-built_in">UIView</span> *view = [[<span class="hljs-built_in">UIView</span> alloc] initWithFrame:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0.0</span>f, <span class="hljs-number">0.0</span>f, size.width, size.height)];  view.backgroundColor = color;  view.layer.cornerRadius = cornerRadius;  <span class="hljs-comment">// 下面方法，第一个参数表示区域大小。第二个参数表示是否是非透明的。如果需要显示半透明效果，需要传NO，否则传YES。第三个参数是屏幕密度</span>  <span class="hljs-built_in">UIGraphicsBeginImageContextWithOptions</span>(view.bounds.size, <span class="hljs-literal">NO</span>, [<span class="hljs-built_in">UIScreen</span> mainScreen].scale);  [view.layer renderInContext:<span class="hljs-built_in">UIGraphicsGetCurrentContext</span>()];  <span class="hljs-built_in">UIImage</span> *image = <span class="hljs-built_in">UIGraphicsGetImageFromCurrentImageContext</span>();  <span class="hljs-built_in">UIGraphicsEndImageContext</span>();  <span class="hljs-keyword">return</span> image;&#125;</code></pre><h5 id="UIImageView"><a href="#UIImageView" class="headerlink" title="UIImageView"></a>UIImageView</h5><p>UIImageView 有四种方式实现圆角：</p><p>1、截取图片方式（性能较好，基本不掉帧）</p><pre><code class="hljs objectivec">+ (<span class="hljs-built_in">UIImage</span> *)dx_imageByRoundCornerRadius:(<span class="hljs-built_in">CGFloat</span>)radius                                 corners:(<span class="hljs-built_in">UIRectCorner</span>)corners                                    size:(<span class="hljs-built_in">CGSize</span>)size                               fillColor:(<span class="hljs-built_in">UIColor</span> *)fillColor&#123;    <span class="hljs-keyword">if</span> (corners != <span class="hljs-built_in">UIRectCornerAllCorners</span>) &#123;        <span class="hljs-built_in">UIRectCorner</span> tmp = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (corners &amp; <span class="hljs-built_in">UIRectCornerTopLeft</span>) tmp |= <span class="hljs-built_in">UIRectCornerBottomLeft</span>;        <span class="hljs-keyword">if</span> (corners &amp; <span class="hljs-built_in">UIRectCornerTopRight</span>) tmp |= <span class="hljs-built_in">UIRectCornerBottomRight</span>;        <span class="hljs-keyword">if</span> (corners &amp; <span class="hljs-built_in">UIRectCornerBottomLeft</span>) tmp |= <span class="hljs-built_in">UIRectCornerTopLeft</span>;        <span class="hljs-keyword">if</span> (corners &amp; <span class="hljs-built_in">UIRectCornerBottomRight</span>) tmp |= <span class="hljs-built_in">UIRectCornerTopRight</span>;        corners = tmp;    &#125;    <span class="hljs-built_in">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="hljs-literal">NO</span>, [<span class="hljs-built_in">UIScreen</span> mainScreen].scale);    <span class="hljs-built_in">CGContextRef</span> context = <span class="hljs-built_in">UIGraphicsGetCurrentContext</span>();    <span class="hljs-built_in">CGRect</span> rect = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, size.width, size.height);    <span class="hljs-built_in">CGContextScaleCTM</span>(context, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);    <span class="hljs-built_in">CGContextTranslateCTM</span>(context, <span class="hljs-number">0</span>, -rect.size.height);      <span class="hljs-built_in">UIBezierPath</span> *path = [<span class="hljs-built_in">UIBezierPath</span> bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:<span class="hljs-built_in">CGSizeMake</span>(radius, radius)];    [fillColor set];    [path fill];         [path addClip];    <span class="hljs-built_in">CGContextDrawPath</span>(context, kCGPathFill);        <span class="hljs-built_in">UIImage</span> *image = <span class="hljs-built_in">UIGraphicsGetImageFromCurrentImageContext</span>();    <span class="hljs-built_in">UIGraphicsEndImageContext</span>();    <span class="hljs-keyword">return</span> image;&#125;</code></pre><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)tx_addCornerWithRadius:(<span class="hljs-built_in">CGFloat</span>)radius corner:(<span class="hljs-built_in">UIRectCorner</span>)corner &#123;    <span class="hljs-keyword">self</span>.image = [<span class="hljs-keyword">self</span>.image dx_imageAddCornerWithRadius:radius andSize:<span class="hljs-keyword">self</span>.bounds.size];&#125;</code></pre><p>实际开发中，网络图片最好截图之后存入缓存，下次直接使用，不用再裁减。YYWebImageView的设计方案即如此。<br><a href="https://github.com/ibireme/YYWebImage">YYWebImage</a><br><a href="https://github.com/walkdianzi/DSImageViewRound/tree/master">fork SDWebImage库修改实现</a></p><p>2、贝塞尔曲线切割圆角（不推荐，掉帧严重）</p><pre><code class="hljs objectivec">- (<span class="hljs-built_in">UIImageView</span> *)roundedRectImageViewWithCornerRadius:(<span class="hljs-built_in">CGFloat</span>)cornerRadius &#123;    <span class="hljs-built_in">UIBezierPath</span> *bezierPath = [<span class="hljs-built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="hljs-keyword">self</span>.bounds cornerRadius:cornerRadius];    <span class="hljs-built_in">CAShapeLayer</span> *layer = [<span class="hljs-built_in">CAShapeLayer</span> layer];    layer.path = bezierPath.CGPath;    <span class="hljs-keyword">self</span>.layer.mask = layer;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;&#125;</code></pre><p>3、绘制四个角的遮罩（使用场景受限）</p><p>在 UIImageView 上添加一个四个角有内容，其它部分是透明的视图，只对 UIImageView 圆角部分进行遮挡。但要保证被遮挡的部分背景色要与周围背景相同，避免穿帮。所以当 UIImageView 处于一个复杂的背景时，是不适合使用这个方法的。</p><p>4、最不推荐做法（当一个页面只有少量圆角图片时才推荐使用）</p><pre><code class="hljs abnf">UIImageView *imageView = [[UIImageView alloc] init]<span class="hljs-comment">;</span>imageView.layer.cornerRadius = <span class="hljs-number">5</span>.f<span class="hljs-comment">;</span>imageView.layer.masksToBounds = YES<span class="hljs-comment">;</span></code></pre><h3 id="扩展：其他会导致离屏渲染的解决方案"><a href="#扩展：其他会导致离屏渲染的解决方案" class="headerlink" title="扩展：其他会导致离屏渲染的解决方案"></a>扩展：其他会导致离屏渲染的解决方案</h3><p>以下离屏渲染操作，按对性能影响等级从高到低进行排序:</p><h5 id="1-shadows（阴影）"><a href="#1-shadows（阴影）" class="headerlink" title="1. shadows（阴影）"></a>1. shadows（阴影）</h5><p>方案：在设置完layer的shadow属性之后，设置layer.shadowPath = [UIBezierPath pathWithCGRect:view.bounds].CGPath;</p><h5 id="2-圆角（前边已解决过）"><a href="#2-圆角（前边已解决过）" class="headerlink" title="2.圆角（前边已解决过）"></a>2.圆角（前边已解决过）</h5><h5 id="3-mask遮罩"><a href="#3-mask遮罩" class="headerlink" title="3.mask遮罩"></a>3.mask遮罩</h5><p>方案：不用mask</p><h5 id="4-allowsGroupOpacity（组不透明）"><a href="#4-allowsGroupOpacity（组不透明）" class="headerlink" title="4. allowsGroupOpacity（组不透明）"></a>4. allowsGroupOpacity（组不透明）</h5><p>开启CALayer的 allowsGroupOpacity 属性后，子 layer 在视觉上的透明度的上限是其父 layer 的 opacity (对应UIView的 alpha )，并且从 iOS 7 以后默认全局开启了这个功能，这样做是为了让子视图与其容器视图保持同样的透明度。<br>方案：关闭 allowsGroupOpacity 属性，按产品需求自己控制layer透明度。 </p><h5 id="5-edge-antialiasing（抗锯齿）"><a href="#5-edge-antialiasing（抗锯齿）" class="headerlink" title="5. edge antialiasing（抗锯齿）"></a>5. edge antialiasing（抗锯齿）</h5><p>方案：不设置 allowsEdgeAntialiasing 属性为YES(默认为NO)</p><h5 id="6-shouldRasterize-光栅化"><a href="#6-shouldRasterize-光栅化" class="headerlink" title="6. shouldRasterize(光栅化)"></a>6. shouldRasterize(光栅化)</h5><p>当视图内容是静态不变时，设置 shouldRasterize(光栅化)为YES，此方案最为实用方便。</p><pre><code class="hljs ini"><span class="hljs-attr">view.layer.shouldRasterize</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span><span class="hljs-attr">view.layer.rasterizationScale</span> = view.layer.contentsScale<span class="hljs-comment">;</span></code></pre><p>但当视图内容是动态变化(如后台下载图片完毕后切换到主线程设置)时，使用此方案反而为增加系统负荷。</p><h5 id="7-Core-Graphics-API-核心绘图"><a href="#7-Core-Graphics-API-核心绘图" class="headerlink" title="7.Core Graphics API(核心绘图)"></a>7.Core Graphics API(核心绘图)</h5><p>Core Graphics API(核心绘图)的绘制操作会导致CPU的离屏渲染。<br>方案：放到后台线程中进行。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><a href="https://github.com/Baichenghui/Study/tree/master/CornerDemo">demo</a></p><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p><a href="https://www.jianshu.com/p/f8a3400836b5">https://www.jianshu.com/p/f8a3400836b5</a><br><a href="https://www.jianshu.com/p/e879aeff93f3">https://www.jianshu.com/p/e879aeff93f3</a><br><a href="https://www.jianshu.com/p/b9bef82eace1">https://www.jianshu.com/p/b9bef82eace1</a><br><a href="https://www.jianshu.com/p/3141c1177d35">https://www.jianshu.com/p/3141c1177d35</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>YYWeakProxy|NSProxy</title>
    <link href="/2019/10/20/YYWeakProxy-NSProxy/"/>
    <url>/2019/10/20/YYWeakProxy-NSProxy/</url>
    
    <content type="html"><![CDATA[<h5 id="YYWeakProxy解决NSTimer循环引用问题："><a href="#YYWeakProxy解决NSTimer循环引用问题：" class="headerlink" title="YYWeakProxy解决NSTimer循环引用问题："></a>YYWeakProxy解决NSTimer循环引用问题：</h5><pre><code><pre><code class="hljs groovy">YYWeakProxy *weakProxy = [YYWeakProxy <span class="hljs-attr">proxyWithTarget:</span>self];   self.timer = [NSTimer <span class="hljs-attr">scheduledTimerWithTimeInterval:</span><span class="hljs-number">1.0</span> <span class="hljs-attr">target:</span>weakProxy <span class="hljs-attr">selector:</span><span class="hljs-meta">@selector</span>(weakProxyTimer) <span class="hljs-attr">userInfo:</span>nil <span class="hljs-attr">repeats:</span>YES];</code></pre></code></pre><h6 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h6><pre><code>生成一个临时对象，让 displayLink 强引用这个临时对象，在这个临时对象中弱引用 self</code></pre><p>self-强-&gt;displayLink-强-&gt;YYWeakProxy-弱-&gt;self，没有形成循环引用</p><h6 id="YYWeakProxy-核心代码："><a href="#YYWeakProxy-核心代码：" class="headerlink" title="YYWeakProxy 核心代码："></a>YYWeakProxy 核心代码：</h6><pre><code><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">weak</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-keyword">id</span> target;+ (<span class="hljs-keyword">instancetype</span>)proxyWithTarget:(<span class="hljs-keyword">id</span>)target &#123;     <span class="hljs-keyword">return</span> [[YYWeakProxy alloc] initWithTarget:target];&#125;<span class="hljs-comment">//将消息接收对象改为 target</span>- (<span class="hljs-keyword">id</span>)forwardingTargetForSelector:(SEL)selector &#123;     <span class="hljs-keyword">return</span> _target;&#125;<span class="hljs-comment">//self 对 target 是弱引用，一旦 target 被释放将调用下面两个方法，如果不实现的话会 crash</span>- (<span class="hljs-keyword">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation &#123;     <span class="hljs-keyword">void</span> *null = <span class="hljs-literal">NULL</span>;     [invocation setReturnValue:&amp;null];&#125;- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)selector &#123;     <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSObject</span> instanceMethodSignatureForSelector:<span class="hljs-keyword">@selector</span>(init)];&#125;</code></pre></code></pre><h6 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h6><pre><code>YYWeakProxy 继承自 NSProxy，是 Foundation 框架两大基类之一，实现了 NSObject 协议。</code></pre><p>NSProxy 做为消息转发的抽象代理类，自身能够处理的方法极少(仅 <NSObject> 接口中定义的部分方法，没有 init 方法，子类必须实现 initWithXXX: forwardInvocation: 和 methodSignatureForSelector: 方法), 所以其它方法都能够按照设计的预期被转发到被代理的对象中。</p><h5 id="NSProxy："><a href="#NSProxy：" class="headerlink" title="NSProxy："></a>NSProxy：</h5><pre><code>NSProxy是一个虚类，你可以通过继承它，并重写这两个方法以实现消息转发到另一个实例。<pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>forwardInvocation:<span class="hljs-params">(NSInvocation *)</span>anInvocation;- <span class="hljs-params">(NSMethodSignature *)</span>methodSignatureForSelector:<span class="hljs-params">(SEL)</span>sel;</code></pre>负责将消息转发到真正的target的代理类。举个例子，你想要卖一件二手物品，但是你并不想直接跟卖家接触（直接向target发消息），这时你去找了一个第三方，你告诉这个第三方你要买什么、出多少钱买、什么时候要等（向代理发消息），第三方再去跟卖家接触并把这些信息转告卖家（转发消息给真实的target），最后通过第三方去完成这个交易。</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
