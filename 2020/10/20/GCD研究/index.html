

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>GCD研究 - b9i60000</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />

  
  
  <meta name="description" content="[TOC]
简介1个进程中可以开启多条线程，每条线程可..."> 
  
  <meta name="author" content="b9i60000"> 

  
    <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  
  
    <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  
  
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  
  
    <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_h1619vhl1nr.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css">

  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        loadingImage: '',
      },
      donate: {
        enable: true,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      motto: {
        api: '',
        default: '我在开了灯的床头下，想问问自己的心啊。'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        alwaysShow: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: true
      }
    }
  </script>

  

  
<meta name="generator" content="Hexo 5.2.0"></head>
<body class="lock-screen">
  <div class="loading"></div>
  


<nav class="navbar">
  <div class="left"></div>
  <div class="center">GCD研究</div>
  <div class="right">
    <i class="iconfont iconmenu j-navbar-menu"></i>
  </div>
</nav>

  <nav class="menu">
  <div class="menu-wrap">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content">
      
      
      
      
      <li class="menu-item"><a href="/ " class="underline"> 首页</a></li>
      
      
      
      
      <li class="menu-item"><a href="/galleries " class="underline"> 摄影</a></li>
      
      
      
      
      <li class="menu-item"><a href="/archives " class="underline"> 归档</a></li>
      
      
      
      
      <li class="menu-item"><a href="/tags " class="underline"> 标签</a></li>
      
      
      
      
      <li class="menu-item"><a href="/categories " class="underline"> 分类</a></li>
      
      
      
      
      <li class="menu-item"><a href="/about " class="underline"> 关于</a></li>
      
    </ul>
    <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  </div>
</nav>
  <main id="main">
  <div class="container" id="container">
    <article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/theme/post-image.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">GCD研究</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>十月 20, 2020</span
        class="post-info-item">
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>47405</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <p>[TOC]</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务<br>多线程技术可以提高程序的执行效率</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>显示\刷新UI界面、处理UI事件（比如点击事件、滚动事件、拖拽事件等）在主线程执行。</p>
<p>耗时操作，开启子线程执行。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行），多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。</p>
<p>如果线程非常多，CPU会在N多线程之间调度，会消耗大量CPU资源，同时每条线程被调度执行的频次也会会降低（线程的执行效率降低）。<br>因此我们一般只开3-5条线程。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>能适当提高程序的执行效率<br>能适当提高资源利用率（CPU、内存利用率）</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>创建线程是有开销的，iOS下主要成本包括：内核数据结构（大约1KB）、栈空间（子线程512KB、主线程1MB，也可以使用-setStackSize:设置，但必须是4K的倍数，而且最小是16K），创建线程大约需要90毫秒的创建时间<br>如果开启大量的线程，会降低程序的性能，线程越多，CPU在调度线程上的开销就越大。<br>程序设计更加复杂：比如线程之间的通信、多线程的数据共享等问题。</p>
<h3 id="多线程方案"><a href="#多线程方案" class="headerlink" title="多线程方案"></a>多线程方案</h3><p>在iOS中多线程方案有多中，但最常用的属GCD和NSOperation，然后NSThread、pthread很少使用。本文主要研究GCD这块内容。</p>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Grand Central Dispatch (GCD), contains language features, runtime libraries, and system enhancements that provide systemic, comprehensive improvements to the support for concurrent code execution on multicore hardware in macOS, iOS, watchOS, and tvOS.</span><br><span class="line"></span><br><span class="line">The BSD subsystem, Core Foundation, and Cocoa APIs have all been extended to use these enhancements to help both the system and your application to run faster, more efficiently, and with improved responsiveness. Consider how difficult it is for a single application to use multiple cores effectively, let alone to do it on different computers with different numbers of computing cores or in an environment with multiple applications competing for those cores. GCD, operating at the system level, can better accommodate the needs of all running applications, matching them to the available system resources in a balanced fashion.</span><br></pre></td></tr></table></figure>

<p>GCD全称为Grand Central Dispatch，包含语言功能，运行时库和系统增强功能，这些功能提供了系统的，全面的改进，以支持在macOS，iOS，watchOS和tvOS中的多核硬件上并发代码执行的支持。</p>
<p>BSD子系统，Core Foundation和Cocoa API均已扩展为使用这些增强功能，以帮助系统和您的应用程序更快，更高效地运行，并提高响应速度。单个应用程序有效地使用多个内核很困难，在具有不同数量计算内核的不同计算机上或在多个应用程序竞争那些内核的环境中进行操作就更困难了。在系统级别运行的GCD可以更好地满足所有正在运行的应用程序的需求，并以平衡的方式将它们与可用的系统资源进行匹配。</p>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><h6 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h6><p>让任务串行执行（一个任务执行完毕后，再执行下一个任务）</p>
<h6 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h6><p>让多个任务并发执行（自动开启多个线程同时执行任务）<br>并发功能只有在异步（dispatch_async）函数下才有效</p>
<h6 id="dispatch-queue-set-specific"><a href="#dispatch-queue-set-specific" class="headerlink" title="dispatch_queue_set_specific"></a>dispatch_queue_set_specific</h6><p>向指定队列里面设置一个标识</p>
<p>向queue1对了中设置一个queueKey1标识:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_set_specific(queue1, queueKey1, &amp;queueKey1,NULL);</span><br></pre></td></tr></table></figure>

<h6 id="dispatch-queue-get-specific"><a href="#dispatch-queue-get-specific" class="headerlink" title="dispatch_queue_get_specific"></a>dispatch_queue_get_specific</h6><p>是获取指定调度队列的上下文键/值数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    const void * queueKey &#x3D; &quot;queueKey&quot;;</span><br><span class="line">    const void * queueKey2 &#x3D; &quot;queueKey2&quot;;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_queue_create(queueKey, NULL);</span><br><span class="line">    dispatch_queue_t queue2 &#x3D; dispatch_queue_create(queueKey2, NULL);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;调用此方法会触发queueFunction函数，留个疑问queueFunction是在什么时候触发？</span><br><span class="line">    dispatch_queue_set_specific(queue, queueKey, &amp;queueKey, queueFunction);</span><br><span class="line">    dispatch_queue_set_specific(queue2, queueKey2, &amp;queueKey2, NULL);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        go();</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue2, ^&#123;</span><br><span class="line">        go();</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    if (dispatch_queue_get_specific(queue, queueKey)) &#123;</span><br><span class="line">        NSLog(@&quot;__run in queue&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;main queue中找不到queueKey，所以这段Log不会触发，使用dispatch_get_specific(queueKey)的原理也一样</span><br><span class="line">    if (dispatch_queue_get_specific(dispatch_get_main_queue(), queueKey)) &#123;</span><br><span class="line">        NSLog(@&quot;__run in main queue&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (dispatch_get_specific(queueKey)) &#123;</span><br><span class="line">        NSLog(@&quot;__run in main queue&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">void go() &#123;</span><br><span class="line">    &#x2F;&#x2F;使用dispatch_sync改变了当前的执行队列，所以这里可以检索到queueKey</span><br><span class="line">    if(dispatch_get_specific(&quot;queueKey&quot;)) &#123;</span><br><span class="line">        NSLog(@&quot;queue&quot;);</span><br><span class="line">    &#125; else if(dispatch_get_specific(&quot;queueKey2&quot;)) &#123;</span><br><span class="line">        NSLog(@&quot;queue2&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;main queue&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void queueFunction() &#123;</span><br><span class="line">    NSLog(@&quot;__queueFunction&quot;);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h6 id="dispatch-get-specific"><a href="#dispatch-get-specific" class="headerlink" title="dispatch_get_specific"></a>dispatch_get_specific</h6><p>在当前队列中取出标识</p>
<p>注意iOS中线程和队列的关系，所有的动作都是在队列中执行的！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"> </span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        static void *queueKey1 &#x3D; &quot;queueKey1&quot;;</span><br><span class="line">        </span><br><span class="line">        dispatch_queue_t queue1 &#x3D; dispatch_queue_create(queueKey1, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        dispatch_queue_set_specific(queue1, queueKey1, &amp;queueKey1, NULL);</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;1. 当前线程是: %@, 当前队列是: %@ 。&quot;,[NSThread currentThread],dispatch_get_current_queue());</span><br><span class="line">        </span><br><span class="line">        if (dispatch_get_specific(queueKey1)) &#123;</span><br><span class="line">            &#x2F;&#x2F;当前队列是主队列，不是queue1队列，所以取不到queueKey1对应的值，故而不执行</span><br><span class="line">            NSLog(@&quot;2. 当前线程是: %@, 当前队列是: %@ 。&quot;,[NSThread currentThread],dispatch_get_current_queue());</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSLog(@&quot;3. 当前线程是: %@, 当前队列是: %@ 。&quot;,[NSThread currentThread],dispatch_get_current_queue());</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dispatch_sync(queue1, ^&#123;</span><br><span class="line">            NSLog(@&quot;4. 当前线程是: %@, 当前队列是: %@ 。&quot;,[NSThread currentThread],dispatch_get_current_queue());</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">            </span><br><span class="line">            if (dispatch_get_specific(queueKey1)) &#123;</span><br><span class="line">                 &#x2F;&#x2F;当前队列是queue1队列，所以能取到queueKey1对应的值，故而执行</span><br><span class="line">                NSLog(@&quot;5. 当前线程是: %@, 当前队列是: %@ 。&quot;,[NSThread currentThread],dispatch_get_current_queue());</span><br><span class="line">                [NSThread sleepForTimeInterval:1];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                NSLog(@&quot;6. 当前线程是: %@, 当前队列是: %@ 。&quot;,[NSThread currentThread],dispatch_get_current_queue());</span><br><span class="line">                [NSThread sleepForTimeInterval:1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        dispatch_async(queue1, ^&#123;</span><br><span class="line">            NSLog(@&quot;7. t当前线程是: %@, 当前队列是: %@ 。&quot;,[NSThread currentThread],dispatch_get_current_queue());</span><br><span class="line">            [NSThread sleepForTimeInterval:1];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        [NSThread sleepForTimeInterval:5];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2016-02-19 14:31:23.390 gcd[96865:820267] 1.当前线程是: &lt;NSThread: 0x1001053e0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;,当前队列是: &lt;OS_dispatch_queue: com.apple.main-thread[0x100059ac0]&gt;。</span><br><span class="line"></span><br><span class="line">2016-02-19 14:31:23.391 gcd[96865:820267] 3.当前线程是: &lt;NSThread: 0x1001053e0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;,当前队列是: &lt;OS_dispatch_queue: com.apple.main-thread[0x100059ac0]&gt;。</span><br><span class="line"></span><br><span class="line">2016-02-19 14:31:24.396 gcd[96865:820267] 4.当前线程是: &lt;NSThread: 0x1001053e0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;,当前队列是: &lt;OS_dispatch_queue: queueKey1[0x103000000]&gt;。</span><br><span class="line"></span><br><span class="line">2016-02-19 14:31:25.400 gcd[96865:820267] 5.当前线程是: &lt;NSThread: 0x1001053e0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;,当前队列是: &lt;OS_dispatch_queue: queueKey1[0x103000000]&gt;。</span><br><span class="line"></span><br><span class="line">2016-02-19 14:31:26.402 gcd[96865:820367] 7. t当前线程是: &lt;NSThread: 0x100105e10&gt;&#123;number &#x3D; 2, name &#x3D; (null)&#125;,当前队列是: &lt;OS_dispatch_queue: queueKey1[0x103000000]&gt;。</span><br><span class="line"></span><br><span class="line">Program ended with exit code: 0 </span><br></pre></td></tr></table></figure>

<h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><h6 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h6><p>在当前线程中执行任务，不具备开启新线程的能力。</p>
<p>注意：使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）</p>
<p>demo：</p>
<p>无论怎样都不会开启新线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> 同步+并发  不会开启新线程，依旧在当前线程执行任务</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)test3 &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;syncConcrrent&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1 %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">     2019-12-20 16:22:30.890416+0800 threadDemo[30526:6608103] 1 &lt;NSThread: 0x600001b9c680&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程死锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)test1 &#123;</span><br><span class="line">    &#x2F;&#x2F; dispatch_async 开启的新线程，在队列 queue 中 ，往queue队列添加同步任务执行，线程卡死</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;asyncSerial&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">     </span><br><span class="line">    dispatch_async(queue, ^&#123; </span><br><span class="line">        NSLog(@&quot;test1 start%@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#x2F;&#x2F;Thread 3: EXC_BAD_INSTRUCTION (code&#x3D;EXC_I386_INVOP, subcode&#x3D;0x0)</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;test1 %@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;test1 end%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">     2019-12-20 09:56:54.932893+0800 threadDemo[11409:6405262] test1 start&lt;NSThread: 0x600002235e40&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;</span><br><span class="line">     </span><br><span class="line">     只打印了第一条。后面出现线程死锁了。</span><br><span class="line">     </span><br><span class="line">     卡住原因：</span><br><span class="line">        1、串行队列，任务需要一个任务执行完毕接着下一个才执行</span><br><span class="line">        2、现在队列queue要执行 dispatch_sync 函数添加一个同步任务block</span><br><span class="line">        3、dispatch_sync 是同步的，需要将添加的任务block立即执行</span><br><span class="line">        4、此时调用 dispatch_sync 函数所在线程处于等待状态，需要block任务执行才继续往后执行，而执行 dispatch_sync 函数的线程与block执行所在线程是同一个线程，所以这个线程一直处于等待状态。不会往后执行，也不会执行block。</span><br><span class="line">     *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">YYKit库中应用</span><br></pre></td></tr></table></figure>
<p>/**<br> YYKit库中，在SDWebImage中也有类似的应用</p>
<p> 用于确保任务在主线程下执行<br> */<br>static inline void _yy_dispatch_sync_on_main_queue(void (^block)(void)) {<br>    if (pthread_main_np()) {<br>        block();<br>    } else {<br>        dispatch_sync(dispatch_get_main_queue(), block);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AFNetworking库中应用</span><br></pre></td></tr></table></figure>
<p>/**<br> AFNetworking库中</p>
<p> AFURLSessionManager 中session创建时用到：<br>    由于session创建在iOS8之前是线程不安全的，所以使用同步+串行队列实现锁的功能</p>
<p> 注意：当前队列与同步函数中任务的队列不是一个队列<br> */<br>//    static void url_session_manager_create_task_safely(dispatch_block_t block) {<br>//        if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) {<br>//            // Fix of bug<br>//            // Open Radar:<a target="_blank" rel="noopener" href="http://openradar.appspot.com/radar?id=5871104061079552">http://openradar.appspot.com/radar?id=5871104061079552</a> (status: Fixed in iOS8)<br>//            // Issue about:<a href="https://github.com/AFNetworking/AFNetworking/issues/2093">https://github.com/AFNetworking/AFNetworking/issues/2093</a><br>//            dispatch_sync(url_session_manager_creation_queue(), block);<br>//        } else {<br>//            block();<br>//        }<br>//    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###### 异步</span><br><span class="line"></span><br><span class="line">在新的线程中执行任务，具备开启新线程的能力</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line"></span><br><span class="line">在主队列，异步执行任务，不会开启新线程</span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)test1 {<br>  dispatch_queue_t queue = dispatch_get_main_queue();</p>
<p>  dispatch_async(queue, ^{ NSLog(@”1 %@”, [NSThread currentThread]); });<br>  dispatch_async(queue, ^{ NSLog(@”2 %@”, [NSThread currentThread]); });<br>  dispatch_async(queue, ^{ NSLog(@”3 %@”, [NSThread currentThread]); });</p>
<p>  /**</p>
<pre><code>  2019-12-18 11:50:33.358149+0800 threadDemo[4613:5504490] 1 &lt;NSThread: 0x600001cde1c0&gt;&#123;number = 1, name = main&#125;
  2019-12-18 11:50:33.358549+0800 threadDemo[4613:5504490] 2 &lt;NSThread: 0x600001cde1c0&gt;&#123;number = 1, name = main&#125;
  2019-12-18 11:50:33.358696+0800 threadDemo[4613:5504490] 3 &lt;NSThread: 0x600001cde1c0&gt;&#123;number = 1, name = main&#125;</code></pre>
<p>   */<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">除主队列外，异步执行任务，都会开启新线程</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)test2 {<br>  dispatch_queue_t queue1= dispatch_queue_create(“asyncSerial”, DISPATCH_QUEUE_SERIAL);<br>  dispatch_async(queue1, ^{ NSLog(@”1-1 %@”, [NSThread currentThread]); });<br>  dispatch_async(queue1, ^{ NSLog(@”1-2 %@”, [NSThread currentThread]); });<br>  dispatch_async(queue1, ^{ NSLog(@”1-3 %@”, [NSThread currentThread]); });</p>
<p>  /**</p>
<pre><code>  2019-12-18 11:53:59.972777+0800 threadDemo[4656:5507191] 1 &lt;NSThread: 0x6000012fd380&gt;&#123;number = 3, name = (null)&#125;
  2019-12-18 11:53:59.973284+0800 threadDemo[4656:5507191] 2 &lt;NSThread: 0x6000012fd380&gt;&#123;number = 3, name = (null)&#125;
  2019-12-18 11:53:59.973437+0800 threadDemo[4656:5507191] 3 &lt;NSThread: 0x6000012fd380&gt;&#123;number = 3, name = (null)&#125;</code></pre>
<p>   */</p>
</li>
</ul>
<p>//    dispatch_queue_t queue2 = dispatch_queue_create(“asyncConcurrent”, DISPATCH_QUEUE_CONCURRENT);<br>//    dispatch_async(queue2, ^{ NSLog(@”2-1 %@”, [NSThread currentThread]); });<br>//    dispatch_async(queue2, ^{ NSLog(@”2-2 %@”, [NSThread currentThread]); });<br>//    dispatch_async(queue2, ^{ NSLog(@”2-3 %@”, [NSThread currentThread]); });</p>
<pre><code>/**
 2019-12-18 11:57:09.136050+0800 threadDemo[4686:5509014] 2-2 &lt;NSThread: 0x600002350000&gt;&#123;number = 6, name = (null)&#125;
 2019-12-18 11:57:09.136154+0800 threadDemo[4686:5509013] 2-1 &lt;NSThread: 0x60000237bd00&gt;&#123;number = 5, name = (null)&#125;
 2019-12-18 11:57:09.136174+0800 threadDemo[4686:5509015] 2-3 &lt;NSThread: 0x60000237b480&gt;&#123;number = 4, name = (null)&#125;
 */</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Dispatch Group</span><br><span class="line"></span><br><span class="line">[参考](https:&#x2F;&#x2F;xiaozhuanlan.com&#x2F;topic&#x2F;0863519247)</span><br><span class="line"> </span><br><span class="line">dispatch_group可以将GCD的任务合并到一个组里来管理，也可以同时监听组里所有任务的执行情况。</span><br><span class="line">    </span><br><span class="line">###### dispatch_group_create</span><br><span class="line"></span><br><span class="line">本质是一个初始value为LONG_MAX的semaphore，通过信号量来实现一组任务的管理，代码如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>dispatch_group_t dispatch_group_create(void) {<br>    //申请内存空间<br>    dispatch_group_t dg = (dispatch_group_t)_dispatch_alloc(<br>            DISPATCH_VTABLE(group), sizeof(struct dispatch_semaphore_s));<br>    //使用LONG_MAX初始化信号量结构体<br>    _dispatch_semaphore_init(LONG_MAX, dg);<br>    return dg;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###### dispatch_group_async</span><br><span class="line"> </span><br><span class="line">加入组的任务异步执行 </span><br><span class="line"></span><br><span class="line">###### dispatch_group_enter &#x2F; leave </span><br><span class="line"></span><br><span class="line">dispatch_group_enter的逻辑是将dispatch_group_t转换成dispatch_semaphore_t后将dsema_value的值减一。</span><br><span class="line"> </span><br><span class="line">应用注意：</span><br><span class="line">1、dispatch_group_enter必须在dispatch_group_leave之前出现</span><br><span class="line">2、dispatch_group_enter和dispatch_group_leave必须成对出现</span><br><span class="line"></span><br><span class="line">demo：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>(void)test1 {<br>  NSLog(@”1:%@”,[NSThread currentThread]);<br>  dispatch_group_t group = dispatch_group_create();<br>  dispatch_queue_t queue = dispatch_queue_create(“concurrentQueue”, DISPATCH_QUEUE_CONCURRENT);</li>
</ul>
<p>//    //注意不要放在这,而应该放在dispatch_group_enter / leave 最后面。<br>//    //否则可额能计数不对，导致提前回调<br>//    dispatch_group_notify(group, queue, ^{<br>//            NSLog(@”2”);<br>//    });</p>
<pre><code>dispatch_group_enter(group);
dispatch_async(queue, ^&#123;
    sleep(1);
    NSLog(@&quot;3:%@&quot;,[NSThread currentThread]);
    dispatch_group_leave(group);
&#125;);

dispatch_group_enter(group);
dispatch_async(queue, ^&#123;
    sleep(3);
    NSLog(@&quot;4:%@&quot;,[NSThread currentThread]);
    dispatch_group_leave(group);
&#125;);

dispatch_group_notify(group, queue, ^&#123;
        NSLog(@&quot;2:%@&quot;,[NSThread currentThread]);
&#125;);

NSLog(@&quot;5:%@&quot;,[NSThread currentThread]);

/**
2019-12-18 16:03:42.575564+0800 threadDemo[5518:5610267] 1:&lt;NSThread: 0x600001c085c0&gt;&#123;number = 1, name = main&#125;
2019-12-18 16:03:42.576226+0800 threadDemo[5518:5610267] 5:&lt;NSThread: 0x600001c085c0&gt;&#123;number = 1, name = main&#125;
2019-12-18 16:03:43.578856+0800 threadDemo[5518:5610368] 3:&lt;NSThread: 0x600001c4ffc0&gt;&#123;number = 4, name = (null)&#125;
2019-12-18 16:03:45.579819+0800 threadDemo[5518:5610366] 4:&lt;NSThread: 0x600001c4b580&gt;&#123;number = 6, name = (null)&#125;
2019-12-18 16:03:45.580037+0800 threadDemo[5518:5610366] 2:&lt;NSThread: 0x600001c4b580&gt;&#123;number = 6, name = (null)&#125;
*/</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###### dispatch_group_wait</span><br><span class="line"></span><br><span class="line">同步等待，直到group里面的block全部执行完毕，才会继续往后执行。</span><br><span class="line"></span><br><span class="line">需要注意下 dispatch_group_wait 的位置，不能放在任务添加之前。</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)test3 {<br>  dispatch_queue_t aDQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>  dispatch_group_t group = dispatch_group_create();<br>  // Add a task to the group<br>  dispatch_group_async(group, aDQueue, ^{</p>
<pre><code>  sleep(2);
  printf(&quot;task 1 \n&quot;);</code></pre>
<p>  });<br>  dispatch_group_async(group, aDQueue, ^{</p>
<pre><code>  printf(&quot;task 2 \n&quot;);</code></pre>
<p>  });</p>
<p>  printf(“wait 1 2 \n”);<br>  //同步等待，直到group里面的block全部执行完毕，才会继续往后执行。<br>  dispatch_group_wait(group, DISPATCH_TIME_FOREVER);<br>  printf(“task 1 2 finished \n”);</p>
<p>  /**</p>
<pre><code>  wait 1 2
  task 2
  task 1
  task 1 2 finished</code></pre>
<p>  */<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###### dispatch_group_notify</span><br><span class="line"></span><br><span class="line">队列组拦截通知模块(内部本身是异步执行的,不会阻塞线程) </span><br><span class="line"></span><br><span class="line">需要注意下 dispatch_group_notify 的位置，不能放在任务添加之前。</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>(void)test2 {<br>  NSLog(@”1:%@”,[NSThread currentThread]);<br>  // 创建队列<br>  dispatch_queue_t queue = dispatch_get_global_queue(0, 0);<br>  // 创建队列组<br>  dispatch_group_t group = dispatch_group_create();</p>
<p>  /*<br>  // 不要写在这，没意义，我们都知道他在组内所有的任务执行完毕会调用 dispatch_group_notify 中的回调块。<br>  // 但是后面还有一句，当组内没有任务时，dispatch_group_notify 中的回调块也会立即执行。<br>  // 队列组拦截通知模块(内部本身是异步执行的,不会阻塞线程)<br>  dispatch_group_notify(group, queue, ^{</p>
<pre><code>  NSLog(@&quot;4:%@&quot;,[NSThread currentThread]);</code></pre>
<p>  });</p>
<p>  2019-12-18 16:07:54.677923+0800 threadDemo[5581:5613688] 1:&lt;NSThread: 0x6000035c57c0&gt;{number = 1, name = main}<br>  2019-12-18 16:07:54.678160+0800 threadDemo[5581:5613816] 4:&lt;NSThread: 0x600003595cc0&gt;{number = 6, name = (null)}<br>  2019-12-18 16:07:55.678663+0800 threadDemo[5581:5613688] 5:&lt;NSThread: 0x6000035c57c0&gt;{number = 1, name = main}<br>  2019-12-18 16:07:56.681079+0800 threadDemo[5581:5613812] 2:&lt;NSThread: 0x6000035995c0&gt;{number = 5, name = (null)}<br>  2019-12-18 16:07:57.680645+0800 threadDemo[5581:5613815] 3:&lt;NSThread: 0x60000359f300&gt;{number = 3, name = (null)}<br>  */</p>
<p>  //队列组异步执行任务<br>  dispatch_group_async(group, queue, ^{</p>
<pre><code>  sleep(2);
  NSLog(@&quot;2:%@&quot;,[NSThread currentThread]);</code></pre>
<p>  });<br>  dispatch_group_async(group, queue, ^{</p>
<pre><code>  sleep(3);
  NSLog(@&quot;3:%@&quot;,[NSThread currentThread]);</code></pre>
<p>  });<br>  // 队列组拦截通知模块(内部本身是异步执行的,不会阻塞线程)<br>  dispatch_group_notify(group, queue, ^{</p>
<pre><code>  NSLog(@&quot;4:%@&quot;,[NSThread currentThread]);</code></pre>
<p>  });</p>
<p>  sleep(1);<br>  NSLog(@”5:%@”,[NSThread currentThread]);</p>
<p>  /*<br>   2019-12-18 16:06:55.380553+0800 threadDemo[5558:5612492] 1:&lt;NSThread: 0x600003d60800&gt;{number = 1, name = main}<br>   2019-12-18 16:06:56.381177+0800 threadDemo[5558:5612492] 5:&lt;NSThread: 0x600003d60800&gt;{number = 1, name = main}<br>   2019-12-18 16:06:57.384415+0800 threadDemo[5558:5612611] 2:&lt;NSThread: 0x600003d30380&gt;{number = 5, name = (null)}<br>   2019-12-18 16:06:58.385496+0800 threadDemo[5558:5612614] 3:&lt;NSThread: 0x600003d351c0&gt;{number = 3, name = (null)}<br>   2019-12-18 16:06:58.385737+0800 threadDemo[5558:5612614] 4:&lt;NSThread: 0x600003d351c0&gt;{number = 3, name = (null)}<br>   */<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### dispatch_block</span><br><span class="line"></span><br><span class="line">[dispatch_block](https:&#x2F;&#x2F;www.cnblogs.com&#x2F;KobeLuo&#x2F;p&#x2F;6464233.html)</span><br><span class="line"></span><br><span class="line">[dispatch_block](https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;5a16dfd36fad)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### dispatch_semaphore</span><br><span class="line"> 信号量，有三个方法：</span><br><span class="line">  </span><br><span class="line">###### dispatch_semaphore_create</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_t dispatch_semaphore_create(long value);</span><br><span class="line">    创建一个信号量，信号量的值为入参 value</span><br><span class="line"></span><br><span class="line">###### dispatch_semaphore_wait</span><br><span class="line"></span><br><span class="line">long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);</span><br><span class="line">    接收一个信号和时间值，若信号的信号量为0，则会阻塞当前线程，直到信号量大于0或者经过输入的时间值；</span><br><span class="line">    若信号量大于0，则会使信号量减1并返回，程序继续住下执行</span><br><span class="line"></span><br><span class="line">###### dispatch_semaphore_signal</span><br><span class="line"></span><br><span class="line">long dispatch_semaphore_signal(dispatch_semaphore_t dsema);</span><br><span class="line">    接收一个信号量，发送信号使信号量的值 +1并返回</span><br><span class="line"> </span><br><span class="line">###### 使用</span><br><span class="line"></span><br><span class="line">应用场景：</span><br><span class="line"></span><br><span class="line">1. 充当锁的功能</span><br><span class="line">2. 异步任务，同步返回（同步获取指定APP在AppStore中的当前版本）</span><br><span class="line">3. 并发控制（实现与NSOperationQueue中max-ConcurrentOperationCount 类似功能。）</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line"></span><br><span class="line">并发控制</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>@implementation SemaphoreMaxConcurrentCount {<br>  dispatch_semaphore_t _semaphore;<br>  dispatch_queue_t _queue;<br>}</p>
</li>
<li><p>(instancetype)init {<br>  return [self initWithMaxConcurrentCount:3];;<br>}</p>
</li>
<li><p>(instancetype)initWithMaxConcurrentCount:(NSInteger)count {<br>  if (self = [super init]) {</p>
<pre><code>  if (count &lt; 1) &#123;
      count = 3;
  &#125;
  _semaphore = dispatch_semaphore_create(count);
  _queue = dispatch_queue_create(&quot;asyncConcurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</code></pre>
<p>  }<br>  return self;<br>}</p>
</li>
</ul>
<ul>
<li>(void)addTask:(TaskBlock)block {<br>  dispatch_async(_queue, ^{<pre><code>  dispatch_semaphore_wait(self-&gt;_semaphore, DISPATCH_TIME_FOREVER);
  dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;
      block();
      dispatch_semaphore_signal(self-&gt;_semaphore);
  &#125;);</code></pre>
  });<br>}</li>
</ul>
<p>@end</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AFNetworking库中</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>/**<br> AFNetworking库中</p>
<p> 获取session中完成的tasks。这个 与 <code>appVersionInAppStore:</code> 方法中的作用差不多。</p>
<p> 都是通过block获取数据，然后将数据直接返回出去，避免了其他地方获取task也要用回调的方式获取数据。</p>
<p> */<br>//- (NSArray *)tasksForKeyPath:(NSString *)keyPath {<br>//    __block NSArray *tasks = nil;<br>//    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);<br>//    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {<br>//        if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) {<br>//            tasks = dataTasks;<br>//        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) {<br>//            tasks = uploadTasks;<br>//        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) {<br>//            tasks = downloadTasks;<br>//        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) {<br>//            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@”@unionOfArrays.self”];<br>//        }<br>//<br>//        dispatch_semaphore_signal(semaphore);<br>//    }];<br>//<br>//    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>//<br>//    return tasks;<br>//}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">充当锁的功能</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>/**<br> 充当锁的功能</p>
<p> 当线程1执行到dispatch_semaphore_wait这一行时，semaphore的信号量为1，所以使信号量-1变为0，并且线程1继续往下执行；<br> 当在线程1NSLog这一行代码还没执行完的时候，又有线程2来访问，执行dispatch_semaphore_wait时由于此时信号量为0，且时间为DISPATCH_TIME_FOREVER,所以会一直阻塞线程2（此时线程2处于等待状态），直到线程1执行完NSLog并执行完dispatch_semaphore_signal使信号量为1后，线程2才能解除阻塞继续住下执行。<br> 这就可以保证同时只有一个线程执行NSLog这一行代码。</p>
<p> */</p>
<ul>
<li><p>(void)test1 {<br>  dispatch_queue_t queue = dispatch_get_global_queue(0, 0);<br>  dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);<br>  for (int i = 0; i &lt; 100; i++) {</p>
<pre><code>  dispatch_async(queue, ^&#123;
      // 相当于加锁
      dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
      NSLog(@&quot;i = %d semaphore = %@&quot;, i, semaphore);
      // 相当于解锁
      dispatch_semaphore_signal(semaphore);
  &#125;);</code></pre>
<p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">异步任务，同步返回(同步获取指定APP在AppStore中的当前版本)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>/**<br>异步任务，同步返回</p>
<p>同步获取指定APP在AppStore中的当前版本<br>*/</p>
</li>
<li><p>(NSString *)appVersionInAppStore:(NSString *)appId {<br>  __block NSString *appVersion = @””;<br>  NSString *url = [NSString stringWithFormat:@”<a target="_blank" rel="noopener" href="https://itunes.apple.com/lookup?id=%25@&quot;,appId%5D">https://itunes.apple.com/lookup?id=%@&quot;,appId]</a>;<br>  NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:url]];</p>
<p>  dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</p>
<p>  NSURLSessionDataTask *dataTask = [[NSURLSession sharedSession] dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {</p>
<pre><code>  NSError *err;
  NSDictionary *jsonData = [NSJSONSerialization JSONObjectWithData:data options:(NSJSONReadingMutableContainers) error:&amp;err];
  if (!err) &#123;
      NSArray *results = jsonData[@&quot;results&quot;];
      if ([results isKindOfClass:[NSArray class]] &amp;&amp; results != nil &amp;&amp; results.count &gt; 0) &#123;
          appVersion = results.firstObject[@&quot;version&quot;];
      &#125;
  &#125;

  dispatch_semaphore_signal(semaphore);</code></pre>
<p>  }];</p>
<p>  [dataTask resume];</p>
<p>  dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</p>
<p>  return appVersion;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### dispatch_barrier</span><br><span class="line"> </span><br><span class="line">在一个并行队列中，有多个线程在执行多个任务，在这个并行队列中，有一个dispatch_barrier任务。这样会使所有在这个dispatch_barrier之后的任务总会等待barrier之前的所有任务结束之后，才会执行。</span><br><span class="line"></span><br><span class="line">dispatch_barrier 又分为 dispatch_barrier_sync 和 dispatch_barrier_async</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.barrier和串行队列配合是完全没有意义的。</span><br><span class="line">barrier的目的是为了在某种情况下，同一个队列中一些并发任务必须在另一些并发任务之后执行，所以需要一个类似于拦截的功能，迫使后执”</span><br><span class="line">“行的任务必须等待。那么，串行队列中的所有任务本身就是按照顺序执行的。</span><br><span class="line"></span><br><span class="line">2.在global queue中使用barrier没有意义。</span><br><span class="line">barrier实现的基本条件是，要写在同一队列中。举个例子，你现在创建了两个并行队列，你在其中一个队列中插入了一个barrier任务，那么你不可能期待他可以在第二个队列中生效，对吧。同样的，每一次使用global queue，系统分配给你的可能是不同的并行队列，你在其中插入一个barrier任务，没有意义。</span><br><span class="line"></span><br><span class="line">###### dispatch_barrier_sync</span><br><span class="line"></span><br><span class="line">dispatch_barrier_sync 中的任务同步执行，会阻塞当前线程</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)test1 {<br>  dispatch_queue_t queue = dispatch_queue_create(“asyncConcurrent”, DISPATCH_QUEUE_CONCURRENT);</p>
<p>  for (int i = 0; i &lt; 10; i++) {</p>
<pre><code>  if (i % 2 == 0) &#123;
      dispatch_async(queue, ^&#123;
          sleep(1);
          NSLog(@&quot;dispatch_barrier_sync 之前的任务:%d&quot;,i);
      &#125;);
  &#125;
  else &#123;
      dispatch_async(queue, ^&#123;
          NSLog(@&quot;dispatch_barrier_sync 之前的任务:%d&quot;,i);
      &#125;);
  &#125;</code></pre>
<p>  }</p>
<p>  dispatch_barrier_sync(queue, ^{</p>
<pre><code>  NSLog(@&quot;dispatch_barrier_sync 任务执行 %@&quot;, [NSThread currentThread]);</code></pre>
<p>  });</p>
<p>  NSLog(@”dispatch_barrier_sync 所在线程 %@”, [NSThread currentThread]);</p>
<p>  for (int i = 0; i &lt; 10; i++) {</p>
<pre><code>  if (i % 2 == 0) &#123;
      dispatch_async(queue, ^&#123;
          sleep(1);
          NSLog(@&quot;dispatch_barrier_sync 之后的任务:%d&quot;,i);
      &#125;);
  &#125;
  else &#123;
      dispatch_async(queue, ^&#123;
          NSLog(@&quot;dispatch_barrier_sync 之后的任务:%d&quot;,i);
      &#125;);
  &#125;</code></pre>
<p>  }</p>
<p>  /**<br>   2019-12-19 13:41:20.335598+0800 threadDemo[8655:6043711] dispatch_barrier_sync 之前的任务:1<br>   2019-12-19 13:41:20.335702+0800 threadDemo[8655:6044001] dispatch_barrier_sync 之前的任务:3<br>   2019-12-19 13:41:20.336030+0800 threadDemo[8655:6044003] dispatch_barrier_sync 之前的任务:5<br>   2019-12-19 13:41:20.336205+0800 threadDemo[8655:6044004] dispatch_barrier_sync 之前的任务:7<br>   2019-12-19 13:41:20.336373+0800 threadDemo[8655:6044005] dispatch_barrier_sync 之前的任务:9<br>   2019-12-19 13:41:21.340593+0800 threadDemo[8655:6043711] dispatch_barrier_sync 之前的任务:6<br>   2019-12-19 13:41:21.340593+0800 threadDemo[8655:6043998] dispatch_barrier_sync 之前的任务:0<br>   2019-12-19 13:41:21.340593+0800 threadDemo[8655:6044001] dispatch_barrier_sync 之前的任务:8<br>   2019-12-19 13:41:21.340593+0800 threadDemo[8655:6044002] dispatch_barrier_sync 之前的任务:4<br>   2019-12-19 13:41:21.340636+0800 threadDemo[8655:6044000] dispatch_barrier_sync 之前的任务:2<br>   2019-12-19 13:41:21.340931+0800 threadDemo[8655:6043503] dispatch_barrier_sync 任务执行 &lt;NSThread: 0x6000014820c0&gt;{number = 1, name = main}<br>   2019-12-19 13:41:21.341159+0800 threadDemo[8655:6043503] dispatch_barrier_sync 所在线程 &lt;NSThread: 0x6000014820c0&gt;{number = 1, name = main}<br>   2019-12-19 13:41:21.341339+0800 threadDemo[8655:6044002] dispatch_barrier_sync 之后的任务:1<br>   2019-12-19 13:41:21.341552+0800 threadDemo[8655:6043998] dispatch_barrier_sync 之后的任务:3<br>   2019-12-19 13:41:21.342288+0800 threadDemo[8655:6044002] dispatch_barrier_sync 之后的任务:5<br>   2019-12-19 13:41:21.342807+0800 threadDemo[8655:6044004] dispatch_barrier_sync 之后的任务:7<br>   2019-12-19 13:41:21.342890+0800 threadDemo[8655:6043711] dispatch_barrier_sync 之后的任务:9<br>   2019-12-19 13:41:22.345189+0800 threadDemo[8655:6044001] dispatch_barrier_sync 之后的任务:2<br>   2019-12-19 13:41:22.345189+0800 threadDemo[8655:6044005] dispatch_barrier_sync 之后的任务:4<br>   2019-12-19 13:41:22.345227+0800 threadDemo[8655:6044003] dispatch_barrier_sync 之后的任务:6<br>   2019-12-19 13:41:22.345227+0800 threadDemo[8655:6044000] dispatch_barrier_sync 之后的任务:0<br>   2019-12-19 13:41:22.345237+0800 threadDemo[8655:6043998] dispatch_barrier_sync 之后的任务:8<br>   */<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###### dispatch_barrier_async</span><br><span class="line"> </span><br><span class="line">dispatch_barrier_async 中的任务异步执行，不会阻塞当前线程</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">- (void)test2 &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;asyncConcurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        if (i % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            dispatch_async(queue, ^&#123;</span><br><span class="line">                sleep(1);</span><br><span class="line">                NSLog(@&quot;dispatch_barrier_sync 之前的任务:%d&quot;,i);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            dispatch_async(queue, ^&#123;</span><br><span class="line">                NSLog(@&quot;dispatch_barrier_sync 之前的任务:%d&quot;,i);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;dispatch_barrier_sync 任务执行 %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;dispatch_barrier_async 所在线程 %@&quot;, [NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        if (i % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            dispatch_async(queue, ^&#123;</span><br><span class="line">                sleep(1);</span><br><span class="line">                NSLog(@&quot;dispatch_barrier_sync 之后的任务:%d&quot;,i);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            dispatch_async(queue, ^&#123;</span><br><span class="line">                NSLog(@&quot;dispatch_barrier_sync 之后的任务:%d&quot;,i);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     2019-12-19 13:40:48.135837+0800 threadDemo[8655:6043503] dispatch_barrier_async 所在线程 &lt;NSThread: 0x6000014820c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     2019-12-19 13:40:48.137458+0800 threadDemo[8655:6043615] dispatch_barrier_sync 之前的任务:1</span><br><span class="line">     2019-12-19 13:40:48.152424+0800 threadDemo[8655:6043615] dispatch_barrier_sync 之前的任务:3</span><br><span class="line">     2019-12-19 13:40:48.152613+0800 threadDemo[8655:6043615] dispatch_barrier_sync 之前的任务:5</span><br><span class="line">     2019-12-19 13:40:48.152732+0800 threadDemo[8655:6043711] dispatch_barrier_sync 之前的任务:7</span><br><span class="line">     2019-12-19 13:40:48.152829+0800 threadDemo[8655:6043615] dispatch_barrier_sync 之前的任务:9</span><br><span class="line">     2019-12-19 13:40:49.140811+0800 threadDemo[8655:6043611] dispatch_barrier_sync 之前的任务:0</span><br><span class="line">     2019-12-19 13:40:49.153305+0800 threadDemo[8655:6043710] dispatch_barrier_sync 之前的任务:6</span><br><span class="line">     2019-12-19 13:40:49.153305+0800 threadDemo[8655:6043609] dispatch_barrier_sync 之前的任务:2</span><br><span class="line">     2019-12-19 13:40:49.153305+0800 threadDemo[8655:6043709] dispatch_barrier_sync 之前的任务:4</span><br><span class="line">     2019-12-19 13:40:49.153359+0800 threadDemo[8655:6043712] dispatch_barrier_sync 之前的任务:8</span><br><span class="line">     2019-12-19 13:40:49.153667+0800 threadDemo[8655:6043712] dispatch_barrier_sync 任务执行 &lt;NSThread: 0x60000140dd00&gt;&#123;number &#x3D; 7, name &#x3D; (null)&#125;</span><br><span class="line">     2019-12-19 13:40:49.153994+0800 threadDemo[8655:6043712] dispatch_barrier_sync 之后的任务:1</span><br><span class="line">     2019-12-19 13:40:49.154061+0800 threadDemo[8655:6043710] dispatch_barrier_sync 之后的任务:3</span><br><span class="line">     2019-12-19 13:40:49.154194+0800 threadDemo[8655:6043710] dispatch_barrier_sync 之后的任务:5</span><br><span class="line">     2019-12-19 13:40:49.154419+0800 threadDemo[8655:6043714] dispatch_barrier_sync 之后的任务:7</span><br><span class="line">     2019-12-19 13:40:49.154460+0800 threadDemo[8655:6043713] dispatch_barrier_sync 之后的任务:9</span><br><span class="line">     2019-12-19 13:40:50.154831+0800 threadDemo[8655:6043709] dispatch_barrier_sync 之后的任务:0</span><br><span class="line">     2019-12-19 13:40:50.154831+0800 threadDemo[8655:6043611] dispatch_barrier_sync 之后的任务:4</span><br><span class="line">     2019-12-19 13:40:50.154869+0800 threadDemo[8655:6043712] dispatch_barrier_sync 之后的任务:6</span><br><span class="line">     2019-12-19 13:40:50.154869+0800 threadDemo[8655:6043615] dispatch_barrier_sync 之后的任务:8</span><br><span class="line">     2019-12-19 13:40:50.154867+0800 threadDemo[8655:6043609] dispatch_barrier_sync 之后的任务:2</span><br><span class="line">     </span><br><span class="line">     *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h5><p>dispatch_once能保证任务只会被执行一次，同时多线程调用也是线程安全的。</p>
<p>原理：dispatch_once用原子性操作block执行完成标记位，同时用信号量确保只有一个线程执行block，等block执行完再唤醒所有等待中的线程。</p>
<p>应用场景：</p>
<ol>
<li>dispatch_once 常被用于创建单例</li>
<li>只需执行一次的函数都可以使用</li>
</ol>
<p>demo:</p>
<p>AFNetworking 库中 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> AFNetworking 库中创建队列</span><br><span class="line"> 1、用到时才创建</span><br><span class="line"> 2、确保只要创建一次</span><br><span class="line"> 3、需要线程安全</span><br><span class="line"> 综上原因，使用 dispatch_once 是最优选择</span><br><span class="line"> </span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F;static dispatch_queue_t url_session_manager_processing_queue() &#123;</span><br><span class="line">&#x2F;&#x2F;    static dispatch_queue_t af_url_session_manager_processing_queue;</span><br><span class="line">&#x2F;&#x2F;    static dispatch_once_t onceToken;</span><br><span class="line">&#x2F;&#x2F;    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">&#x2F;&#x2F;        af_url_session_manager_processing_queue &#x3D; dispatch_queue_create(&quot;com.alamofire.networking.session.manager.processing&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">&#x2F;&#x2F;    &#125;);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    return af_url_session_manager_processing_queue;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>单利</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)test1 &#123;</span><br><span class="line">    TDManager *manager1 &#x3D; [TDManager shareManager];</span><br><span class="line">    TDManager *manager2 &#x3D; [TDManager new];</span><br><span class="line">    TDManager *manager3 &#x3D; [[TDManager alloc] init];</span><br><span class="line">    TDManager *manager4 &#x3D; [manager1 copy];</span><br><span class="line">    TDManager *manager5 &#x3D; [manager1 mutableCopy];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;manager1:%p&quot;,manager1);</span><br><span class="line">    NSLog(@&quot;manager2:%p&quot;,manager2);</span><br><span class="line">    NSLog(@&quot;manager3:%p&quot;,manager3);</span><br><span class="line">    NSLog(@&quot;manager4:%p&quot;,manager4);</span><br><span class="line">    NSLog(@&quot;manager5:%p&quot;,manager5);</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">     打印内存地址都一致，起到了单利效果</span><br><span class="line">     </span><br><span class="line">     2019-12-20 17:00:15.974273+0800 threadDemo[30701:6628246] manager1:0x6000021d68b0</span><br><span class="line">     2019-12-20 17:00:15.974428+0800 threadDemo[30701:6628246] manager2:0x6000021d68b0</span><br><span class="line">     2019-12-20 17:00:15.974544+0800 threadDemo[30701:6628246] manager3:0x6000021d68b0</span><br><span class="line">     2019-12-20 17:00:15.974634+0800 threadDemo[30701:6628246] manager4:0x6000021d68b0</span><br><span class="line">     2019-12-20 17:00:15.974714+0800 threadDemo[30701:6628246] manager5:0x6000021d68b0</span><br><span class="line">     *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h5><p>dispatch_apply类似一个for循环，会在指定的dispatch queue中运行block任务n次.<br>    如果队列是并发队列，则会并发执行block任务;<br>    如果队列是串行队列，则会串行在当前队列执行block任务;<br>    dispatch_apply是一个同步调用，block任务执行n次后才返回。</p>
<p>demo:</p>
<p>串行队列中执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 串行队列中执行,效率还是略高于普通的 for 循环</span><br><span class="line">- (void)test1 &#123;</span><br><span class="line">    NSLog(@&quot;start&quot;);</span><br><span class="line">      </span><br><span class="line">    dispatch_queue_t queue&#x3D; dispatch_queue_create(&quot;asyncSerial&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">&#x2F;&#x2F;    dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;asyncConcurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    CFTimeInterval startTimeInterval &#x3D; CACurrentMediaTime();</span><br><span class="line">    &#x2F;&#x2F;dispatch_apply是一个同步调用，block任务执行都执行完才返回，会卡住当前线程（无论串行还是并发队列）</span><br><span class="line">    dispatch_apply(10000, queue, ^(size_t i) &#123;</span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F;        [NSThread sleepForTimeInterval:arc4random()%1];</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;%zu %@&quot;,i,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    CFTimeInterval endTimeInterval &#x3D; CACurrentMediaTime();</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;endTimeInterval - startTimeInterval:%f&quot;,endTimeInterval - startTimeInterval);</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">     2019-12-19 15:46:19.281002+0800 threadDemo[9336:6115616] 0 &lt;NSThread: 0x6000008aa0c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     2019-12-19 15:46:19.281440+0800 threadDemo[9336:6115616] 1 &lt;NSThread: 0x6000008aa0c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     2019-12-19 15:46:19.281440+0800 threadDemo[9336:6115616] 2 &lt;NSThread: 0x6000008aa0c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     2019-12-19 15:46:19.281440+0800 threadDemo[9336:6115616] 3 &lt;NSThread: 0x6000008aa0c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     ....</span><br><span class="line">     2019-12-19 15:46:19.281002+0800 threadDemo[9336:6115616] 9997 &lt;NSThread: 0x6000008aa0c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     2019-12-19 15:46:19.281440+0800 threadDemo[9336:6115616] 9998 &lt;NSThread: 0x6000008aa0c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     2019-12-19 15:46:19.282302+0800 threadDemo[9336:6115616] 9999 &lt;NSThread: 0x6000008aa0c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     2019-12-19 15:46:19.282819+0800 threadDemo[9336:6115616] end</span><br><span class="line">     2019-12-19 15:46:19.283203+0800 threadDemo[9336:6115616] endTimeInterval - startTimeInterval:4.206515</span><br><span class="line">     </span><br><span class="line">     *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>并发队列执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 并发队列中执行，比串行队列效率高</span><br><span class="line">- (void)test2 &#123;</span><br><span class="line">    NSLog(@&quot;start&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;asyncConcurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    CFTimeInterval startTimeInterval &#x3D; CACurrentMediaTime();</span><br><span class="line">    &#x2F;&#x2F;dispatch_apply是一个同步调用，block任务执行都执行完才返回，会卡住当前线程（无论串行还是并发队列）</span><br><span class="line">    dispatch_apply(10000, queue, ^(size_t i) &#123;</span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F;        [NSThread sleepForTimeInterval:arc4random()%1];</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;%zu %@&quot;,i,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    CFTimeInterval endTimeInterval &#x3D; CACurrentMediaTime();</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;endTimeInterval - startTimeInterval:%f&quot;,endTimeInterval - startTimeInterval);</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line"></span><br><span class="line">     2019-12-19 16:23:13.700098+0800 threadDemo[9717:6141471] 0 &lt;NSThread: 0x600002f5a140&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     2019-12-19 16:23:13.700240+0800 threadDemo[9717:6141471] 1 &lt;NSThread: 0x600002f5a140&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     2019-12-19 16:23:13.700767+0800 threadDemo[9717:6141471] 2 &lt;NSThread: 0x600002f5a140&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     ...</span><br><span class="line">     2019-12-19 16:23:17.318679+0800 threadDemo[9717:6141471] 9995 &lt;NSThread: 0x600002f5a140&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     2019-12-19 16:23:17.318908+0800 threadDemo[9717:6141715] 9996 &lt;NSThread: 0x600002fd6900&gt;&#123;number &#x3D; 8, name &#x3D; (null)&#125;</span><br><span class="line">     2019-12-19 16:23:17.319090+0800 threadDemo[9717:6141471] 9997 &lt;NSThread: 0x600002f5a140&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     2019-12-19 16:23:17.319294+0800 threadDemo[9717:6141714] 9998 &lt;NSThread: 0x600002fd6780&gt;&#123;number &#x3D; 7, name &#x3D; (null)&#125;</span><br><span class="line">     2019-12-19 16:23:17.319498+0800 threadDemo[9717:6141662] 9999 &lt;NSThread: 0x600002fd6740&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;</span><br><span class="line">     2019-12-19 16:23:17.321036+0800 threadDemo[9717:6141471] end</span><br><span class="line">     2019-12-19 16:23:17.321507+0800 threadDemo[9717:6141471] endTimeInterval - startTimeInterval:3.620898</span><br><span class="line">     *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h5><p>延时函数，不会卡住所在线程</p>
<p>demo:</p>
<p>任务执行所在队列为主队列，任务在主线程中执行的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)test1 &#123;</span><br><span class="line">    NSLog(@&quot;1 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;2 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;3 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">     2019-12-19 14:58:46.529442+0800 threadDemo[8900:6083577] 1 &lt;NSThread: 0x6000036b8b80&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     2019-12-19 14:58:46.529659+0800 threadDemo[8900:6083577] 3 &lt;NSThread: 0x6000036b8b80&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     2019-12-19 14:58:48.529967+0800 threadDemo[8900:6083577] 2 &lt;NSThread: 0x6000036b8b80&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line"></span><br><span class="line">     *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改任务执行所在队列为并发队列. 任务是在子线程中执行的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)test2 &#123;</span><br><span class="line">    NSLog(@&quot;1 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;2 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;3 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">     2019-12-19 15:00:48.693679+0800 threadDemo[8943:6085531] 1 &lt;NSThread: 0x600000d72ac0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     2019-12-19 15:00:48.694252+0800 threadDemo[8943:6085531] 3 &lt;NSThread: 0x600000d72ac0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     2019-12-19 15:00:50.855673+0800 threadDemo[8943:6085641] 2 &lt;NSThread: 0x600000d21080&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;</span><br><span class="line"></span><br><span class="line">     *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改任务执行所在队列为自定义的串行队列. 任务是在子线程中执行的.<br>通过查看打印结果，很明显延时函数底层肯定是异步执行任务。只有在主队列时任务才在主线程执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)test3 &#123;</span><br><span class="line">    NSLog(@&quot;1 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;syncConcrrent&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;3 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">     2019-12-19 15:09:06.207532+0800 threadDemo[9037:6090879] 1 &lt;NSThread: 0x600001960f40&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     2019-12-19 15:09:06.207745+0800 threadDemo[9037:6090879] 3 &lt;NSThread: 0x600001960f40&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">     2019-12-19 15:09:08.207879+0800 threadDemo[9037:6090962] 2 &lt;NSThread: 0x6000019ee4c0&gt;&#123;number &#x3D; 8, name &#x3D; (null)&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Dispatch-Source"><a href="#Dispatch-Source" class="headerlink" title="Dispatch Source"></a>Dispatch Source</h5><p>Dispatch Source是BSD系统内核惯有功能kqueue的包装，kqueue是在XNU内核中发生各种事件时，在应用程序编程方执行处理的技术。<br> 它的CPU负荷非常小，尽量不占用资源。当事件发生时，Dispatch Source会在指定的Dispatch Queue中执行事件的处理。</p>
<p> dispatch_source_t<br> 一共有一下几种类型（dispatch_source_type_t):</p>
<p> 监控进程：DISPATCH_SOURCE_TYPE_PROC,<br> 定时器：DISPATCH_SOURCE_TYPE_TIMER,<br> 从描述符中读取数据：DISPATCH_SOURCE_TYPE_READ,<br> 向描述符中写入字符：DISPATCH_SOURCE_TYPE_WRITE,<br> 监控文件系统对象:DISPATCH_SOURCE_TYPE_VNODE,…..</p>
<p> demo演示定时器使用</p>
<p> Dispatch Source使用最多的就是用来实现定时器，source创建后默认是暂停状态，需要手动调用dispatch_resume启动定时器。dispatch_after只是封装调用了dispatch source定时器，然后在回调函数中执行定义的block。</p>
<p> Dispatch Source定时器使用时也有一些需要注意的地方，不然很可能会引起crash：</p>
<p> 1、循环引用：因为dispatch_source_set_event_handler回调是个block，在添加到source的链表上时会执行copy并被source强引用，如果block里持有了self，self又持有了source的话，就会引起循环引用。正确的方法是使用weak+strong或者提前调用dispatch_source_cancel取消timer。</p>
<p> 2、dispatch_resume和dispatch_suspend调用次数需要平衡，如果重复调用dispatch_resume则会崩溃,因为重复调用会让dispatch_resume代码里if分支不成立，从而执行了DISPATCH_CLIENT_CRASH(“Over-resume of an object”)导致崩溃。</p>
<p> 3、source在suspend状态下，如果直接设置source = nil或者重新创建source都会造成crash。正确的方式是在resume状态下调用dispatch_source_cancel(source)后再重新创建。</p>
<h6 id="GCD定时器"><a href="#GCD定时器" class="headerlink" title="GCD定时器"></a>GCD定时器</h6><p>定时器不受runloop影响，效率高。</p>
<p>demo:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)test1 &#123;</span><br><span class="line">    __block int timeout&#x3D;30; &#x2F;&#x2F;倒计时时间</span><br><span class="line">    dispatch_source_t _timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</span><br><span class="line">    dispatch_source_set_timer(_timer, dispatch_time(DISPATCH_TIME_NOW, 0), 1 * NSEC_PER_SEC, 0);</span><br><span class="line">    dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">        if(timeout&lt;&#x3D;0)&#123; &#x2F;&#x2F;倒计时结束，关闭</span><br><span class="line">            dispatch_source_cancel(_timer);</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                &#x2F;&#x2F;设置界面的按钮显示 根据自己需求设置</span><br><span class="line">                NSLog(@&quot;time 倒计时结束&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int minutes &#x3D; timeout &#x2F; 60;</span><br><span class="line">            int seconds &#x3D; timeout % 60;</span><br><span class="line">            NSString *strTime &#x3D; [NSString stringWithFormat:@&quot;%d分%.2d秒后重新获取验证码&quot;,minutes, seconds];</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                &#x2F;&#x2F;设置界面的按钮显示 根据自己需求设置</span><br><span class="line">                NSLog(@&quot;strTime %@&quot;,strTime);</span><br><span class="line">            &#125;);</span><br><span class="line">            timeout--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;启动timer</span><br><span class="line">    dispatch_resume(_timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>只有当多个线程同时去访问并且修改一块资源的内容时可能会有线程安全问题。</p>
<p>当多线程只是访问并不做修改，不会出现线程安全问题。</p>
<p>举例：</p>
<p>假设银行卡有余额1000元，有2个线程A、B；<br>现在A、B同时查询余额，得到的都是1000元；<br>然后A线程存入1000元，余额为1000 + 1000 = 2000；<br>然后B线程取出500元，余额为1000 - 500 = 500；<br>这样就出现线程安全问题了，下次去查询余额就只有500了😹</p>
<p>为了保证线程安全，需要给线程加锁。</p>
<h5 id="同步方案"><a href="#同步方案" class="headerlink" title="同步方案"></a>同步方案</h5><h6 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h6><p>OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源</p>
<p>目前已经不再安全，可能会出现优先级反转问题</p>
<p>如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁</p>
<p>需要导入头文件#import &lt;libkern/OSAtomic.h&gt;</p>
<h6 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h6><p>os_unfair_lock用于取代不安全的OSSpinLock ，从iOS10开始才支持</p>
<p>从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等</p>
<p>需要导入头文件#import &lt;os/lock.h&gt;</p>
<p><img   class="lazyload" data-original="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2361" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="6a32356cd62bffb395c55eff0729375d.png"> </p>
<h6 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h6><p>mutex叫做”互斥锁”，等待锁的线程会处于休眠状态</p>
<p>需要导入头文件#import &lt;pthread.h&gt;</p>
<p><img   class="lazyload" data-original="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2362" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="9848ab391ea130b47de60ac90949c5d7.png"><br><img   class="lazyload" data-original="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2363" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="1e9bf9133cafc7fe1e68e53239f70754.png"><br><img   class="lazyload" data-original="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2364" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="8d423ed41c44ae90fe1f4e55b26964f9.png"><br><img   class="lazyload" data-original="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2365" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="eeeb5c6a5d872001eb1f1c7917d810e0.png"></p>
<h6 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h6><p>semaphore叫做”信号量”</p>
<p>信号量的初始值，可以用来控制线程并发访问的最大数量</p>
<p>信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步</p>
<p><img   class="lazyload" data-original="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2366" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="844e0aa7a21c56f9568325ebf1df04b2.png"></p>
<h6 id="dispatch-queue-DISPATCH-QUEUE-SERIAL"><a href="#dispatch-queue-DISPATCH-QUEUE-SERIAL" class="headerlink" title="dispatch_queue(DISPATCH_QUEUE_SERIAL)"></a>dispatch_queue(DISPATCH_QUEUE_SERIAL)</h6><p>直接使用GCD的串行队列，也是可以实现线程同步的</p>
<p><img   class="lazyload" data-original="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2367" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="4da7c092e947d453289322166866701b.png"></p>
<h6 id="NSLock、NSRecursiveLock"><a href="#NSLock、NSRecursiveLock" class="headerlink" title="NSLock、NSRecursiveLock"></a>NSLock、NSRecursiveLock</h6><p>NSLock是对mutex普通锁的封装</p>
<p><img   class="lazyload" data-original="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2371" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="1cb32ab8ac4967086fbbee75dbb15433.png"><br><img   class="lazyload" data-original="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2372" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="f288c06d4f718baddb110b329023936d.png"><br><img   class="lazyload" data-original="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2373" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="c02fbd60aa09ed858fec23c3b8d4a6a3.png"></p>
<p>NSRecursiveLock也是对mutex递归锁的封装，API跟NSLock基本一致</p>
<h6 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h6><p>NSCondition是对mutex和cond的封装</p>
<p><img   class="lazyload" data-original="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2370" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="5f93ec4282fecd19e347dd383be722ec.png"></p>
<h6 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h6><p>NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值</p>
<p><img   class="lazyload" data-original="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2369" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="65483fd9373eed4ce11ef7ecb2b60fda.png"></p>
<h6 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h6><p>@synchronized是对mutex递归锁的封装</p>
<p>源码查看：objc4中的objc-sync.mm文件</p>
<p>@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作</p>
<p><img   class="lazyload" data-original="evernotecid://3252F98A-C8F0-41C3-834D-D7F7BDDE3269/appyinxiangcom/11846024/ENResource/p2368" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="27d559c23065755f60c6afe842dd3096.png"></p>
<h5 id="同步方案性能比较"><a href="#同步方案性能比较" class="headerlink" title="同步方案性能比较"></a>同步方案性能比较</h5><p>性能从高到低排序<br>os_unfair_lock<br>OSSpinLock<br>dispatch_semaphore<br>pthread_mutex<br>dispatch_queue(DISPATCH_QUEUE_SERIAL)<br>NSLock<br>NSCondition<br>pthread_mutex(recursive)<br>NSRecursiveLock<br>NSConditionLock<br>@synchronized</p>
<h5 id="自旋-互斥锁"><a href="#自旋-互斥锁" class="headerlink" title="自旋 / 互斥锁"></a>自旋 / 互斥锁</h5><h6 id="什么是自旋锁"><a href="#什么是自旋锁" class="headerlink" title="什么是自旋锁"></a>什么是自旋锁</h6><p>等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源</p>
<h6 id="什么是互斥锁"><a href="#什么是互斥锁" class="headerlink" title="什么是互斥锁"></a>什么是互斥锁</h6><p>等待锁的线程会处于休眠状态</p>
<h6 id="什么情况使用自旋锁更划算？"><a href="#什么情况使用自旋锁更划算？" class="headerlink" title="什么情况使用自旋锁更划算？"></a>什么情况使用自旋锁更划算？</h6><p>预计线程等待锁的时间很短<br>加锁的代码（临界区）经常被调用，但竞争情况很少发生<br>CPU资源不紧张<br>多核处理器</p>
<h6 id="什么情况使用互斥锁更划算？"><a href="#什么情况使用互斥锁更划算？" class="headerlink" title="什么情况使用互斥锁更划算？"></a>什么情况使用互斥锁更划算？</h6><p>预计线程等待锁的时间较长<br>单核处理器<br>临界区有IO操作<br>临界区代码复杂或者循环量大<br>临界区竞争非常激烈 </p>
<h5 id="高性能读写安全方案"><a href="#高性能读写安全方案" class="headerlink" title="高性能读写安全方案"></a>高性能读写安全方案</h5><h6 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h6><p>同一时间，只能有1个线程进行写的操作<br>同一时间，允许有多个线程进行读的操作<br>同一时间，不允许既有写的操作，又有读的操作</p>
<h6 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h6><p>“多读单写”，经常用于文件等数据的读写操作，实现方案有<br>pthread_rwlock：读写锁<br>dispatch_barrier_async：异步栅栏调用</p>
<p>demo:</p>
<p>由于 NSMutableDictionary 线程是不安全的。</p>
<p>现在实现一个线程安全的可变字典</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^ThreadSafeBlock)(ThreadSafeMutableDictionary *dict, NSString *key, id object);</span><br><span class="line"></span><br><span class="line">@implementation ThreadSafeMutableDictionary &#123;</span><br><span class="line">    dispatch_queue_t _concurrentQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self &#x3D; [super init]) &#123;</span><br><span class="line">        _concurrentQueue &#x3D; dispatch_queue_create(@&quot;com.thread.ThreadSafeMutableDictionary&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)objectForKey:(NSString *)key block:(ThreadSafeBlock)block &#123;</span><br><span class="line">    id cKey &#x3D; [key copy];</span><br><span class="line">    __weak __typeof__(self) weakSelf &#x3D; self;</span><br><span class="line"></span><br><span class="line">    dispatch_sync(_concurrentQueue, ^&#123;</span><br><span class="line">        ThreadSafeMutableDictionary *strongSelf &#x3D; weakSelf;</span><br><span class="line">        if (!strongSelf) &#123;</span><br><span class="line">            block(nil,cKey,nil);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        id object &#x3D; [strongSelf objectForKey:cKey];</span><br><span class="line">        block(strongSelf,cKey,object);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setObject:(id)object forKey:(NSString *)key block:(ThreadSafeBlock)block &#123;</span><br><span class="line">    if (!key || !object) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *aKey &#x3D; [key copy];</span><br><span class="line">    __weak __typeof__(self) weakSelf &#x3D; self;</span><br><span class="line">    dispatch_barrier_async(_concurrentQueue, ^&#123;</span><br><span class="line">        ThreadSafeMutableDictionary *strongSelf &#x3D; weakSelf;</span><br><span class="line">        if (!strongSelf) &#123;</span><br><span class="line">            block(nil,aKey,nil);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [self setObject:object forKey:aKey];</span><br><span class="line">        if (block) &#123;</span><br><span class="line">            block(strongSelf,aKey,object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="多线程优化"><a href="#多线程优化" class="headerlink" title="多线程优化"></a>多线程优化</h3><h5 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h5><h6 id="尽量减少队列切换"><a href="#尽量减少队列切换" class="headerlink" title="尽量减少队列切换"></a>尽量减少队列切换</h6><p>当线程数量超过 CPU 核心数量，CPU 核心通过线程调度切换用户态线程，意味着有上下文的转换，过多的上下文切换会带来资源开销。 </p>
<p>如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;x.x.x&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">- (void)tast1 &#123;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F;执行任务1</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            &#x2F;&#x2F;任务1完成</span><br><span class="line">            [self tast2];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)tast2 &#123;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F;执行任务2</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            &#x2F;&#x2F;任务2完成</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个并行队列，调用 tast1 会执行两个任务，任务2要等待任务1执行完成，这里一共有四次队列的切换。其实是没必要的。</p>
<p>优化后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;x.x.x&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    &#x2F;&#x2F;执行任务1</span><br><span class="line">    &#x2F;&#x2F;执行任务2</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        &#x2F;&#x2F;任务1、2完成</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="控制线程数量"><a href="#控制线程数量" class="headerlink" title="控制线程数量"></a>控制线程数量</h6><p>使用 GCD 并行队列，当任务过多且耗时较长时，队列会开辟大量的线程，而部分线程里面的耗时任务已经耗尽了 CPU 资源，所以其他的线程也只能等待 CPU 时间片，过多的线程也会让线程调度过于频繁。</p>
<p>GCD 中并行队列并不能限制线程数量，可以创建多个串行队列来模拟并行的效果，业界知名框架 YYKit 就做了这个逻辑，通过和 CPU 核心数量相同的串行队列轮询返回来达到并行队列的效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_queue_t YYAsyncLayerGetDisplayQueue() &#123;</span><br><span class="line">&#x2F;&#x2F;最大队列数量</span><br><span class="line">#define MAX_QUEUE_COUNT 16</span><br><span class="line">&#x2F;&#x2F;队列数量</span><br><span class="line">    static int queueCount;</span><br><span class="line">&#x2F;&#x2F;使用栈区的数组存储队列</span><br><span class="line">    static dispatch_queue_t queues[MAX_QUEUE_COUNT];</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    static int32_t counter &#x3D; 0;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">&#x2F;&#x2F;串行队列数量和处理器数量相同</span><br><span class="line">        queueCount &#x3D; (int)[NSProcessInfo processInfo].activeProcessorCount;</span><br><span class="line">        queueCount &#x3D; queueCount &lt; 1 ? 1 : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;</span><br><span class="line">&#x2F;&#x2F;创建串行队列，设置优先级</span><br><span class="line">        if ([UIDevice currentDevice].systemVersion.floatValue &gt;&#x3D; 8.0) &#123;</span><br><span class="line">            for (NSUInteger i &#x3D; 0; i &lt; queueCount; i++) &#123;</span><br><span class="line">                dispatch_queue_attr_t attr &#x3D; dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0);</span><br><span class="line">                queues[i] &#x3D; dispatch_queue_create(&quot;com.ibireme.yykit.render&quot;, attr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (NSUInteger i &#x3D; 0; i &lt; queueCount; i++) &#123;</span><br><span class="line">                queues[i] &#x3D; dispatch_queue_create(&quot;com.ibireme.yykit.render&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">                dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#x2F;&#x2F;轮询返回队列</span><br><span class="line">    uint32_t cur &#x3D; (uint32_t)OSAtomicIncrement32(&amp;counter);</span><br><span class="line">    return queues[cur % queueCount];</span><br><span class="line">#undef MAX_QUEUE_COUNT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="线程优先级权衡"><a href="#线程优先级权衡" class="headerlink" title="线程优先级权衡"></a>线程优先级权衡</h6><p>线程调度除了轮转法以外，还有优先级调度的方案，在线程调度时，高优先级的线程会更早的执行。有两个概念需要明确：<br>    a. IO 密集型线程：频繁等待的线程，等待的时候会让出时间片。<br>    b. CPU 密集型线程：很少等待的线程，意味着长时间占用着 CPU。 </p>
<p>这样就会存在一个问题：<br>    当CPU密集型线程优先级较高，而且长期霸占CPU大部分资源，这样IO密集型线程由于优先级较低，就持续的等待，产生线程饿死的现象。这时系统会根据情况提高IO密集型线程的优先级，但即使这样，等待也是需要时间的。</p>
<p>这样可以考虑优化的方向：<br>    a. 让 IO 密集型线程优先级高于 CPU 密集型线程。<br>    b. 让紧急的任务拥有更高的优先级。</p>
<h6 id="主线程任务的优化"><a href="#主线程任务的优化" class="headerlink" title="主线程任务的优化"></a>主线程任务的优化</h6><p>这摘抄了yykit作者的提出的部分内容<a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a></p>
<p>一些耗时的操作尽量移动到子线程执行。</p>
<p>但是有些操作必须在主线程，比如 UI 类组件的初始化及其布局。 </p>
<p>那么主线程的优化有哪些方案可以参考呢？</p>
<p>1、尽量使用轻量级对象</p>
<p>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。</p>
<p>2、尽量减少对象的调整</p>
<p>当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p>
<p>3、对象销毁其实是可以在后台线程执行的</p>
<p>这时yykit作者提倡的方式：</p>
<p>需要注意的是下面的例子中，如果self.array在别的地方还有依赖，那tmp不是唯一的销毁helper。这一套就没用了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSArray *tmp &#x3D; self.array;</span><br><span class="line">self.array &#x3D; nil;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [tmp class];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>4、内存复用</p>
<p>最常见的就是cell复用，避免了大量cell对象的创建，节省内存的同时也节省了开辟内存所消耗的时间。</p>
<p>5、懒加载任务</p>
<p>懒加载对象，用到时再创建，可以减少没必要的内存开销。开辟内存是要时间的。勉强算是变相的吧任务进行了拆分，不必初始化时就创建一系列对象。</p>
<p>6、任务拆分排队执行</p>
<p>将大量的任务拆分开来，监听Runloop运行状态，当runloop将要休息的时候，让 Runloop 循环周期执行少量任务。</p>
<p>。。。</p>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p><a href="https://github.com/apple/swift-corelibs-libdispatch">GCD源码</a></p>
<p><a target="_blank" rel="noopener" href="http://www.gnustep.org/resources/downloads.php">GNUstep</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/">不再安全的 OSSpinLock</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/594d15d6c6a7">iOS 如何高效的使用多线程</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaozhuanlan.com/u/3785694919">深入浅出 GCD</a></p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><a href="https://github.com/Baichenghui/Study/tree/master/threadDemo">threadDemo</a></p>

      </section>
      <section class="extra">
        
        <ul class="copyright">
  
  <li><strong>本文作者：</strong>b9i60000</li>
  <li><strong>本文链接：</strong><a href="https://github.com/Baichenghui/2020/10/20/GCD%E7%A0%94%E7%A9%B6/index.html">https://github.com/Baichenghui/2020/10/20/GCD%E7%A0%94%E7%A9%B6/index.html</a></li>
  <li><strong>版权声明：</strong>本博客所有文章均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"
      rel="external nofollow" target="_blank"> BY-NC-SA </a>许可协议，转载请注明出处！</li>
  
</ul>
        
        
        <section class="donate">
  <div class="qrcode">
    <img   class="lazyload" data-original="https://pic.izhaoo.com/alipay.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
        
<nav class="nav">
  
    <a href="/2020/10/20/iOS-%E9%95%BF%E8%BF%9E%E6%8E%A5-socket-%E8%82%A1%E7%A5%A8%E6%96%B9%E5%90%91%E7%A0%94%E7%A9%B6/"><i class="iconfont iconleft"></i>iOS 长连接 socket 股票方向研究</a>
  
  
    <a href="/2020/10/20/YBTaskScheduler-%E7%A0%94%E7%A9%B6/">YBTaskScheduler 研究<i class="iconfont iconright"></i></a>
  
</nav>

      </section>
      
      <section class="comments">
  
  <div class="btn" id="comments-btn">查看评论</div>
  
  
</section>
      
    </section>
  </div>
</article>
  </div>
</main>
  <footer class="footer">
  <div class="footer-social">
    
    
    
    
    
    <a href="tencent://message/?Menu=yes&uin=894519210 " target="_blank" onMouseOver="this.style.color= '#12B7F5'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconQQ "></i>
    </a>
    
    
    
    
    
    <a href="javascript:; " target="_blank" onMouseOver="this.style.color= '#09BB07'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconwechat-fill "></i>
    </a>
    
    
    
    
    
    <a href="https://www.instagram.com/izhaoo/ " target="_blank" onMouseOver="this.style.color= '#DA2E76'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconinstagram "></i>
    </a>
    
    
    
    
    
    <a href="https://github.com/izhaoo " target="_blank" onMouseOver="this.style.color= '#24292E'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  icongithub-fill "></i>
    </a>
    
    
    
    
    
    <a href="mailto:izhaoo@163.com " target="_blank" onMouseOver="this.style.color='#FFBE5B'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconmail"></i>
    </a>
    
  </div>
  <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  <div class="fab fab-daovoice">
    <i class="iconfont iconcomment"></i>
  </div>
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
</body>


<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>






<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>






<script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>






<script src="/js/utils.js"></script>
<script src="/js/modules.js"></script>
<script src="/js/zui.js"></script>
<script src="/js/script.js"></script>





<script>
  (function (i, s, o, g, r, a, m) {
    i["DaoVoiceObject"] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o), m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    a.charset = "utf-8";
    m.parentNode.insertBefore(a, m)
  })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
    "//widget.daovoice.io/widget/0f81ff2f.js", "daovoice")
  daovoice('init', {
    app_id: "abcdefg"
  }, {
    launcher: {
      disableLauncherIcon: true,
    },
  });
  daovoice('update');
</script>



<script>
  (function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>


<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?4c204d8bc027a0455b5fc642ac334ca8";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>










</html>